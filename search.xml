<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好，欢迎光临我的博客</title>
    <url>/2021/04/10/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%89%E4%B8%B4%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
    <content><![CDATA[<h2 id="这篇说明将更好地帮助你在-lt-Mr-l’s-World-gt-里畅游"><a href="#这篇说明将更好地帮助你在-lt-Mr-l’s-World-gt-里畅游" class="headerlink" title="这篇说明将更好地帮助你在&lt;Mr.l’s World&gt;里畅游"></a>这篇说明将更好地帮助你在&lt;<em>Mr.l’s World</em>&gt;里畅游</h2><blockquote>
<p><strong>博客使用简介</strong></p>
</blockquote>
<ol>
<li><p>博客界面<strong>左侧</strong>有<strong>侧边菜单</strong>为你提供快捷帮助<strong>&lt;<em>手机用户请点击屏幕左上角按钮以呼出菜单</em>&gt;</strong></p>
</li>
<li><p>博客界面<strong>右下角</strong>有<strong>暗夜模式按钮</strong>为你提供更好的浏览体验</p>
</li>
<li><p>博客同样为你提供<strong>文章查找</strong>功能，功能按钮在<strong>侧边菜单</strong>的下方</p>
</li>
<li><p>博客已开放<strong>评论留言系统</strong>，欢迎大家在评论区留下你的足迹</p>
</li>
<li><p><strong>《语言之美-古诗丽词》</strong>与<strong>《语言之美-新句美文》</strong>两篇文章将不定时持续更新，欢迎大家在评论区留下自己的珍藏，我也很乐意将其收录进文章里面</p>
</li>
<li><p><strong>光影画廊</strong>模块里展示了一些我个人的绘画作品，希望大家能够喜欢(^-^)</p>
</li>
<li><p>由于对留言系统提供支持的<strong>LeanCloud</strong>将定期对不绑定自由域名数据库进行清理，所以在2020年之后，您的留言数据将只会保留一段时间。对于您留言的流失，我感到很抱歉，也很遗憾。不过还是衷心感谢您愿意在我的留言区留下您的足迹。</p>
</li>
</ol>
<blockquote>
<p>技术支持</p>
</blockquote>
<ul>
<li><strong>Powered by</strong> <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li>
<li><strong>Theme:</strong> <a href="https://shen-yu.gitee.io/" target="_blank" rel="noopener">Ayer</a></li>
</ul>
<hr>
<p> (以下是博客更新日志，日志从2020/4/11开始记录，你<strong>可以点击</strong>&lt;阅读更多…&gt;来快速掌握博客更新动向，或者在<strong>文章概览</strong>里浏览最近更新的文章)</p>
<a id="more"></a>

<hr>
<blockquote>
<p><strong>博客更新日志</strong></p>
</blockquote>
<ul>
<li><strong>2021/4/10</strong></li>
</ul>
<ol>
<li>添加《希尔密码(Hill Cipher)的C++实现》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2021/2/4</strong></li>
</ul>
<ol>
<li>添加《元胞自动机在模拟森林野火的应用（Matlab实现）》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2021/2/2</strong></li>
</ul>
<ol>
<li>添加《遗传算法的Matlab实现》</li>
<li>添加《负指数分布的卡方检验（Matlab实现）》</li>
<li>添加《泊松分布的卡方检验（Matlab实现）》</li>
</ol>
<p><strong>小结</strong>：添加三篇文章</p>
<hr>
<ul>
<li><strong>2021/2/1</strong></li>
</ul>
<ol>
<li>更新《语言之美-新句美文》</li>
</ol>
<p><strong>小结</strong>：《语言之美-新句美文》添加一篇文章</p>
<hr>
<ul>
<li><strong>2021/1/30</strong></li>
</ul>
<ol>
<li>更新《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：《语言之美-古诗丽词》添加一篇文章</p>
<hr>
<ul>
<li><strong>2021/1/28</strong></li>
</ul>
<ol>
<li>更新《语言之美-新句美文》</li>
</ol>
<p><strong>小结</strong>：《语言之美-新句美文》添加一篇文章</p>
<hr>
<ul>
<li><strong>2021/1/26</strong></li>
</ul>
<ol>
<li>重新上线博客留言系统</li>
</ol>
<p><strong>小结</strong>：修复博客BUG</p>
<hr>
<ul>
<li><strong>2021/1/6</strong></li>
</ul>
<ol>
<li>更新《语言之美-新句美文》</li>
<li>更新《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：更新两篇文章</p>
<hr>
<ul>
<li><strong>2021/1/2</strong></li>
</ul>
<ol>
<li>大幅更新《语言之美-古诗丽词》</li>
<li>大幅更新《语言之美-新句美文》</li>
</ol>
<p><strong>小结</strong>：更新两篇文章</p>
<hr>
<ul>
<li><strong>2020/12/23</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加两篇诗</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/12/13</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加一篇诗</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/12/11</strong></li>
</ul>
<ol>
<li>修改文章《希尔密码(Hill Cipher)的Python实现》</li>
</ol>
<p><strong>小结</strong>：修改一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/29</strong></li>
</ul>
<ol>
<li>修改文章《希尔密码(Hill Cipher)的Python实现》</li>
</ol>
<p><strong>小结</strong>：修改一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/28</strong></li>
</ul>
<ol>
<li>添加文章《希尔密码(Hill Cipher)的Python实现》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/27</strong></li>
</ul>
<ol>
<li>修改文章《利用reshape重塑数》</li>
<li>添加文章《Python 从输入端读取多行数据》</li>
</ol>
<p><strong>小结</strong>：修改一篇文章，添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/25</strong></li>
</ul>
<ol>
<li>修改文章《费诺(Fano)编码的Python实现》</li>
<li>添加文章《哈夫曼(Huffman)编码的Python实现》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章,修改一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/24</strong></li>
</ul>
<ol>
<li>修改文章《天平秤球问题的Python实现》</li>
<li>添加文章《香农(Shannon)编码的Python实现》</li>
<li>添加文章《费诺(Fano)编码的Python实现》</li>
</ol>
<p><strong>小结</strong>：添加两篇文章，修改一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/18</strong></li>
</ul>
<ol>
<li>添加文章《天平秤球问题的Python实现》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/11/06</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加一篇诗</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/10/31</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加一篇诗</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/10/16</strong></li>
</ul>
<ol>
<li>添加文章《利用Python从文本中提取单词》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/10/13</strong></li>
</ul>
<ol>
<li>添加文章《解决C++从输入流读取所需个数的数据后，多余数据仍存在输入流中的问题》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/10/12</strong></li>
</ul>
<ol>
<li>添加文章《解决C++ ifstream 读取文件总多读一次问题》</li>
</ol>
<p><strong>小结</strong>：添加一篇文章</p>
<hr>
<ul>
<li><strong>2020/10/06</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加一篇诗</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/9/30</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加两篇词</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/9/26</strong></li>
</ul>
<ol>
<li>《语言之美-古诗丽词》添加词《一剪梅·舟过吴江》</li>
<li>修复无法评论BUG</li>
</ol>
<p><strong>小结</strong>：更新一篇文章；修复BUG</p>
<hr>
<ul>
<li><strong>2020/8/26</strong></li>
</ul>
<ol>
<li>更新文章《语言之美-新句美文》</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/8/19</strong></li>
</ul>
<ol>
<li>更新文章《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/8/14</strong></li>
</ul>
<ol>
<li>添加文章《Python网络爬虫示例（有道词典）》</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/8/9</strong></li>
</ul>
<ol>
<li>添加文章《关于在Python中利用pandas读取与保存csv文件失败的解决方法(‘utf-8’编码格式不对)》</li>
<li>删除两篇低价值文章，合并一篇文章</li>
</ol>
<p><strong>小结</strong>：更新一篇文章，清理两篇文章</p>
<hr>
<ul>
<li><strong>2020/8/6</strong></li>
</ul>
<ol>
<li>更新文章《语言之美-古诗丽词》</li>
<li>添加文章《R语言dgCMatrix稀疏矩阵结构》</li>
<li>修复文章评论系统</li>
</ol>
<p><strong>小结</strong>：更新两篇文章，修复无法评论小BUG</p>
<hr>
<ul>
<li><strong>2020/7/21</strong></li>
</ul>
<ol>
<li>更新文章《R语言学习笔记》、《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：更新两篇文章</p>
<hr>
<ul>
<li><strong>2020/7/20</strong></li>
</ul>
<ol>
<li>更新文章《R语言学习笔记》</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/7/19</strong></li>
</ul>
<ol>
<li>更新文章《R语言学习笔记》</li>
</ol>
<p><strong>小结</strong>：更新一篇文章</p>
<hr>
<ul>
<li><strong>2020/7/5</strong></li>
</ul>
<ol>
<li>更新文章《Hexo进行本地预览》为《Hexo常用命令》</li>
<li>小幅修改博客导航文字</li>
</ol>
<p><strong>小结</strong>：更新一篇文章，小幅修改博客导航文字</p>
<hr>
<ul>
<li><strong>2020/7/5</strong></li>
</ul>
<ol>
<li>更新文章《R语言学习笔记》</li>
</ol>
<p><strong>小结</strong>：更新文章《R语言学习笔记》</p>
<hr>
<ul>
<li><strong>2020/7/5</strong></li>
</ul>
<ol>
<li>添加文章《C++学习笔记》</li>
</ol>
<p><strong>小结</strong>：添加文章《C++学习笔记》</p>
<hr>
<ul>
<li><strong>2020/7/4</strong></li>
</ul>
<ol>
<li>修复了博客<em>文章分类</em>模块无法显示的问题</li>
</ol>
<p><strong>小结</strong>：博客小BUG修复</p>
<hr>
<ul>
<li><strong>2020/7/2</strong></li>
</ul>
<ol>
<li>添加文章《R语言学习笔记》</li>
</ol>
<p><strong>小结</strong>：添加文章<strong>《R语言学习笔记》</strong></p>
<hr>
<ul>
<li><strong>2020/5/9</strong></li>
</ul>
<ol>
<li>更新文章《《python深度学习》笔记》</li>
<li>添加文章《Python中copy与deepcopy的区别》</li>
</ol>
<p><strong>小结</strong>：今日更新文章<strong>《《python深度学习》笔记》</strong>，添加文章<strong>《Python中copy与deepcopy的区别》</strong></p>
<hr>
<ul>
<li><strong>2020/5/8</strong></li>
</ul>
<ol>
<li>更新文章《《python深度学习》笔记》</li>
<li>优化《语言之美-古诗丽词》检索界面</li>
</ol>
<p><strong>小结</strong>：今日更新文章<strong>《《python深度学习》笔记》</strong>，优化<strong>《语言之美-古诗丽词》</strong>检索界面(2020/5/8 09:42 PV:460 UV:206)</p>
<hr>
<ul>
<li><strong>2020/5/7</strong></li>
</ul>
<ol>
<li>更新文章《《python深度学习》笔记》</li>
</ol>
<p><strong>小结</strong>：今日更新文章<strong>《《python深度学习》笔记》</strong>(2020/5/7 11:14 PV:460 UV:206)</p>
<hr>
<ul>
<li><strong>2020/5/6</strong></li>
</ul>
<ol>
<li>添加文章《《python深度学习》笔记》</li>
</ol>
<p><strong>小结</strong>：今日添加文章<strong>《《python深度学习》笔记》</strong>(2020/5/6 12:08 PV:456 UV:204)</p>
<hr>
<ul>
<li><strong>2020/4/30</strong></li>
</ul>
<ol>
<li>光影画廊模块上线</li>
<li>小幅更新文章《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：今日<strong>上线光影画廊模块</strong>,更新<strong>《语言之美-古诗丽词》</strong>(2020/4/30 20:39 PV:436 UV:188)</p>
<hr>
<ul>
<li><strong>2020/4/29</strong></li>
</ul>
<ol>
<li>小幅更新文章《语言之美-古诗丽词》与《语言之美-新句美文》</li>
<li>更改两处滚动标题</li>
</ol>
<p><strong>小结</strong>：今日<strong>更新两篇文章</strong>(2020/4/29 22:34 PV:430 UV:183)</p>
<hr>
<ul>
<li><strong>2020/4/23</strong></li>
</ul>
<ol>
<li>更新文章《利用tf.concat()与np.concatenate来拼接向量》</li>
</ol>
<p><strong>小结</strong>：今日<strong>更新一篇文章</strong>(2020/4/23 10:13 PV:411 UV:165)</p>
<hr>
<ul>
<li><strong>2020/4/22</strong></li>
</ul>
<ol>
<li>添加文章《利用reshape重塑numpy数组》，《利用tf.concat()与np.concatenate来拼接向量》</li>
</ol>
<p><strong>小结</strong>：今日<strong>添加两篇文章</strong>(2020/4/22 10:13 PV:399 UV:158)</p>
<hr>
<ul>
<li><strong>2020/4/20</strong></li>
</ul>
<ol>
<li>更新文章《语言之美-古诗丽词》</li>
</ol>
<p><strong>小结</strong>：今日<strong>大幅更新《语言之美-古诗丽词》并优化文章排版</strong>(2020/4/20 22:05 PV:390 UV:153)</p>
<hr>
<ul>
<li><strong>2020/4/16</strong></li>
</ul>
<ol>
<li>更新文章《《数据结构与算法》笔记(Python语言实现)》(2020/4/16 20:06 PV:385 UV:150)</li>
</ol>
<hr>
<ul>
<li><strong>2020/4/14</strong></li>
</ul>
<ol>
<li>更新文章《Pandas在Python语言下的基础使用》(2020/4/14 22:12 PV:376 UV:145)</li>
</ol>
<hr>
<ul>
<li><strong>2020/4/13</strong></li>
</ul>
<ol>
<li>更新文章《《Python机器学习基础教程》笔记(scikit-learn框架)》</li>
<li>更新文章《python画散点图[plt.scatter()]以及矩阵散点图[pd.scatter_matrix()]详解》（待优化）</li>
<li>暂时搁置文章《Pandas在Python语言下的基础使用》</li>
<li>暂时搁置文章《《数据结构与算法》笔记(Python语言实现)》</li>
</ol>
<p><strong>小结</strong>：今日更新主要<strong>优化文章排版</strong>，<strong>更新两篇文章</strong>(2020/4/13 22:05 PV:374 UV:143)</p>
<hr>
<ul>
<li><strong>2020/4/11</strong></li>
</ul>
<ol>
<li>博客现在已经<strong>能够在文章中插入图片</strong>，但<strong>光影画廊仍然无法在云端显示图片</strong></li>
<li>博客现在已开放<strong>评论留言系统</strong>，并能够<strong>置顶文章</strong></li>
</ol>
<p><strong>小结</strong>：今天<strong>无文章更新</strong>，主要是<strong>完善博客功能</strong>(2020/4/11 22:39 PV:354 UV:138)</p>
]]></content>
  </entry>
  <entry>
    <title>语言之美-古诗丽词</title>
    <url>/2021/01/30/%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BE%8E-%E5%8F%A4%E8%AF%97%E4%B8%BD%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="2021上半年收录"><a href="#2021上半年收录" class="headerlink" title="2021上半年收录"></a>2021上半年收录</h1><h3 id="《雨霖铃·寒蝉凄切》-宋-柳永"><a href="#《雨霖铃·寒蝉凄切》-宋-柳永" class="headerlink" title="《雨霖铃·寒蝉凄切》-[宋] 柳永"></a>《雨霖铃·寒蝉凄切》-[宋] 柳永</h3><blockquote>
<p><strong>寒蝉凄切，对长亭晚，骤雨初歇。<br>都门帐饮无绪，留恋处，兰舟催发。<br>执手相看泪眼，竟无语凝噎。<br>念去去，千里烟波，暮霭沉沉楚天阔。<br>多情自古伤离别，更那堪，冷落清秋节！<br>今宵酒醒何处？杨柳岸，晓风残月。<br>此去经年，应是良辰好景虚设。<br>便纵有千种风情，更与何人说？</strong></p>
</blockquote>
<hr>
<h3 id="《葬花吟》-清-曹雪芹"><a href="#《葬花吟》-清-曹雪芹" class="headerlink" title="《葬花吟》-[清] 曹雪芹"></a>《葬花吟》-[清] 曹雪芹</h3><ul>
<li><p><strong>花谢花飞花满天，红消香断有谁怜？</strong></p>
</li>
<li><p><strong>满纸荒唐言 一把辛酸泪 都云作者痴 谁解其中味</strong></p>
</li>
</ul>
<hr>
<h3 id="《赠别二首》-唐-杜牧"><a href="#《赠别二首》-唐-杜牧" class="headerlink" title="《赠别二首》-[唐] 杜牧"></a>《赠别二首》-[唐] 杜牧</h3><blockquote>
<p><strong>娉娉袅袅十三余，豆蔻梢头二月初。<br>春风十里扬州路，卷上珠帘总不如。</strong></p>
</blockquote>
<hr>
<h3 id="《卜算子·赠妓》-宋-谢直"><a href="#《卜算子·赠妓》-宋-谢直" class="headerlink" title="《卜算子·赠妓》-[宋] 谢直"></a>《卜算子·赠妓》-[宋] 谢直</h3><blockquote>
<p><strong>双桨浪花平，夹岸青山锁。你自归家我自归，说着如何过。<br>我断不思量，你莫思量我。将你从前与我心，付与他人可。</strong></p>
</blockquote>
<hr>
<h3 id="《一剪梅》-宋-李清照"><a href="#《一剪梅》-宋-李清照" class="headerlink" title="《一剪梅》-[宋] 李清照"></a>《一剪梅》-[宋] 李清照</h3><blockquote>
<p><strong>红藕香残玉簟秋，轻解罗裳，独上兰舟。云中谁寄锦书来？雁字回时，月满西楼。<br>花自飘零水自流，一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</strong></p>
</blockquote>
<hr>
<h3 id="《玉楼春·别后不知君远近》-宋-欧阳修"><a href="#《玉楼春·别后不知君远近》-宋-欧阳修" class="headerlink" title="《玉楼春·别后不知君远近》-[宋] 欧阳修"></a>《玉楼春·别后不知君远近》-[宋] 欧阳修</h3><blockquote>
<p><strong>别后不知君远近。触目凄凉多少闷。渐行渐远渐无书，水阔鱼沉何处问。<br>夜深风竹敲秋韵。万叶千声皆是恨。故欹单枕梦中寻，梦又不成灯又烬。</strong></p>
</blockquote>
<a id="more"></a>
<hr>
<h3 id="《水龙吟·次韵章质夫杨花词》-宋-苏轼"><a href="#《水龙吟·次韵章质夫杨花词》-宋-苏轼" class="headerlink" title="《水龙吟·次韵章质夫杨花词》-[宋] 苏轼"></a>《水龙吟·次韵章质夫杨花词》-[宋] 苏轼</h3><blockquote>
<p><strong>似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被莺呼起。<br>不恨此花飞尽，恨西园，落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花点点，是离人泪。</strong></p>
</blockquote>
<hr>
<h3 id="《送李副使赴碛西官军》-唐-岑参"><a href="#《送李副使赴碛西官军》-唐-岑参" class="headerlink" title="《送李副使赴碛西官军》-[唐] 岑参"></a>《送李副使赴碛西官军》-[唐] 岑参</h3><blockquote>
<p><strong>火山六月应更热，赤亭道口行人绝。<br>知君惯度祁连城，岂能愁见轮台月。<br>脱鞍暂入酒家垆，送君万里西击胡。<br>功名只向马上取，真是英雄一丈夫。</strong></p>
</blockquote>
<hr>
<h3 id="《不第后赋菊》-唐-黄巢"><a href="#《不第后赋菊》-唐-黄巢" class="headerlink" title="《不第后赋菊》-[唐] 黄巢"></a>《不第后赋菊》-[唐] 黄巢</h3><blockquote>
<p><strong>待到秋来九月八，我花开后百花杀。<br>冲天香阵透长安，满城尽带黄金甲。</strong></p>
</blockquote>
<hr>
<h3 id="《长相思·山一程》-清-纳兰性德"><a href="#《长相思·山一程》-清-纳兰性德" class="headerlink" title="《长相思·山一程》-[清] 纳兰性德"></a>《长相思·山一程》-[清] 纳兰性德</h3><blockquote>
<p><strong>山一程，水一程，身向榆关那畔行，夜深千帐灯。<br>风一更，雪一更，聒碎乡心梦不成，故园无此声。</strong></p>
</blockquote>
<hr>
<h3 id="《临江仙·寒柳》-清-纳兰性德"><a href="#《临江仙·寒柳》-清-纳兰性德" class="headerlink" title="《临江仙·寒柳》-[清] 纳兰性德"></a>《临江仙·寒柳》-[清] 纳兰性德</h3><blockquote>
<p><strong>飞絮飞花何处是，层冰积雪摧残，疏疏一树五更寒。爱他明月好，憔悴也相关。<br>最是繁丝摇落后，转教人忆春山。湔裙梦断续应难。西风多少恨，吹不散眉弯。</strong></p>
</blockquote>
<hr>
<h3 id="《钗头凤·世情薄》-宋-唐婉"><a href="#《钗头凤·世情薄》-宋-唐婉" class="headerlink" title="《钗头凤·世情薄》-[宋] 唐婉"></a>《钗头凤·世情薄》-[宋] 唐婉</h3><blockquote>
<p><strong>世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残。欲笺心事，独语斜阑。难，难，难！<br>人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊。怕人寻问，咽泪装欢。瞒，瞒，瞒！</strong></p>
</blockquote>
<hr>
<h3 id="《浣溪沙·谁念西风独自凉》-清-纳兰性德"><a href="#《浣溪沙·谁念西风独自凉》-清-纳兰性德" class="headerlink" title="《浣溪沙·谁念西风独自凉》-[清] 纳兰性德"></a>《浣溪沙·谁念西风独自凉》-[清] 纳兰性德</h3><blockquote>
<p><strong>谁念西风独自凉？<br>萧萧黄叶闭疏窗。<br>沉思往事立残阳。<br>被酒莫惊春睡重，赌书消得泼茶香。<br>当时只道是寻常。</strong></p>
</blockquote>
<hr>
<h3 id="《唐多令·芦叶满汀洲》-宋-刘过"><a href="#《唐多令·芦叶满汀洲》-宋-刘过" class="headerlink" title="《唐多令·芦叶满汀洲》-[宋] 刘过"></a>《唐多令·芦叶满汀洲》-[宋] 刘过</h3><blockquote>
<p><strong>芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。<br>黄鹤断矶头，故人今在否？旧江山浑是新愁。欲买桂花同载酒，终不似，少年游。</strong></p>
</blockquote>
<!--more-->
<hr>
<h1 id="2020下半年收录"><a href="#2020下半年收录" class="headerlink" title="2020下半年收录"></a>2020下半年收录</h1><h3 id="《国风·豳风·七月》-先秦-佚名"><a href="#《国风·豳风·七月》-先秦-佚名" class="headerlink" title="《国风·豳风·七月》-[先秦] 佚名"></a>《国风·豳风·七月》-[先秦] 佚名</h3><blockquote>
<p><strong>七月在野，八月在宇，九月在户，十月蟋蟀入我床下。</strong></p>
</blockquote>
<hr>
<h3 id="《题龙阳县青草湖》-元-唐珙"><a href="#《题龙阳县青草湖》-元-唐珙" class="headerlink" title="《题龙阳县青草湖》-[元] 唐珙"></a>《题龙阳县青草湖》-[元] 唐珙</h3><blockquote>
<p><strong>西风吹老洞庭波，一夜湘君白发多。<br>醉后不知天在水，满船清梦压星河。</strong></p>
</blockquote>
<hr>
<h3 id="《采桑子·谁翻乐府凄凉曲》-清-纳兰性德"><a href="#《采桑子·谁翻乐府凄凉曲》-清-纳兰性德" class="headerlink" title="《采桑子·谁翻乐府凄凉曲》-[清] 纳兰性德"></a>《采桑子·谁翻乐府凄凉曲》-[清] 纳兰性德</h3><blockquote>
<p><strong>谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵。<br>不知何事萦怀抱？醒也无聊，醉也无聊，梦也何曾到谢桥。</strong></p>
</blockquote>
<hr>
<h3 id="《杂诗三首·其二》-唐-王维"><a href="#《杂诗三首·其二》-唐-王维" class="headerlink" title="《杂诗三首·其二》-[唐] 王维"></a>《杂诗三首·其二》-[唐] 王维</h3><blockquote>
<p><strong>君自故乡来，应知故乡事。<br>来日绮窗前，寒梅著花未？</strong></p>
</blockquote>
<hr>
<h3 id="《相思》-唐-王维"><a href="#《相思》-唐-王维" class="headerlink" title="《相思》-[唐] 王维"></a>《相思》-[唐] 王维</h3><blockquote>
<p><strong>红豆生南国，春来发几枝。<br>愿君多采撷，此物最相思。</strong></p>
</blockquote>
<hr>
<h3 id="《自遣》-唐-罗隐"><a href="#《自遣》-唐-罗隐" class="headerlink" title="《自遣》-[唐] 罗隐"></a>《自遣》-[唐] 罗隐</h3><blockquote>
<p><strong>得即高歌失即休，多愁多恨亦悠悠。<br>今朝有酒今朝醉，明日愁来明日愁。</strong></p>
</blockquote>
<hr>
<h3 id="《妒花》-明-唐寅"><a href="#《妒花》-明-唐寅" class="headerlink" title="《妒花》-[明] 唐寅"></a>《妒花》-[明] 唐寅</h3><blockquote>
<p><strong>昨夜海棠初着雨，<br>数点轻盈娇欲语。<br>佳人晓起出兰房，<br>折来对镜化红妆。<br>问郎花好奴颜好？<br>郎道不如花窈窕。<br>佳人闻语发娇嗔，<br>不信死花胜活人。<br>将花揉碎掷郎前：<br>请郎今日伴花眠！</strong></p>
</blockquote>
<hr>
<h3 id="《近试上张籍水部-近试上张水部-闺意献张水部》-唐-朱庆馀"><a href="#《近试上张籍水部-近试上张水部-闺意献张水部》-唐-朱庆馀" class="headerlink" title="《近试上张籍水部 / 近试上张水部 / 闺意献张水部》-[唐] 朱庆馀"></a>《近试上张籍水部 / 近试上张水部 / 闺意献张水部》-[唐] 朱庆馀</h3><blockquote>
<p><strong>洞房昨夜停红烛，待晓堂前拜舅姑。<br>妆罢低声问夫婿，画眉深浅入时无。</strong></p>
</blockquote>
<hr>
<h3 id="《一剪梅·舟过吴江》-宋-蒋捷"><a href="#《一剪梅·舟过吴江》-宋-蒋捷" class="headerlink" title="《一剪梅·舟过吴江》-[宋] 蒋捷"></a>《一剪梅·舟过吴江》-[宋] 蒋捷</h3><blockquote>
<p><strong>一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。<br>何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。</strong></p>
</blockquote>
<hr>
<h3 id="《宣州谢朓楼饯别校书叔云》-唐-李白"><a href="#《宣州谢朓楼饯别校书叔云》-唐-李白" class="headerlink" title="《宣州谢朓楼饯别校书叔云》-[唐] 李白"></a>《宣州谢朓楼饯别校书叔云》-[唐] 李白</h3><blockquote>
<p><strong>弃我去者，昨日之日不可留；<br>乱我心者，今日之日多烦忧。<br>长风万里送秋雁，对此可以酣高楼。<br>蓬莱文章建安骨，中间小谢又清发。<br>俱怀逸兴壮思飞，欲上青天览明月。<br>抽刀断水水更流，举杯消愁愁更愁。<br>人生在世不称意，明朝散发弄扁舟。</strong></p>
</blockquote>
<hr>
<h3 id="《卜算子·我住长江头》-宋-李之仪"><a href="#《卜算子·我住长江头》-宋-李之仪" class="headerlink" title="《卜算子·我住长江头》-[宋] 李之仪"></a>《卜算子·我住长江头》-[宋] 李之仪</h3><blockquote>
<p><strong>我住长江头，君住长江尾。日日思君不见君，共饮长江水。<br>此水几时休，此恨何时已。只愿君心似我心，定不负相思意。</strong></p>
</blockquote>
<hr>
<h3 id="《清平乐·春归何处》-宋-黄庭坚"><a href="#《清平乐·春归何处》-宋-黄庭坚" class="headerlink" title="《清平乐·春归何处》-[宋] 黄庭坚"></a>《清平乐·春归何处》-[宋] 黄庭坚</h3><blockquote>
<p><strong>春归何处。寂寞无行路。若有人知春去处。换取归来同住。<br>春无踪迹谁知。除非问取黄鹂。百啭无人能解，因风飞过蔷薇。</strong></p>
</blockquote>
<hr>
<h1 id="2020上半年收录"><a href="#2020上半年收录" class="headerlink" title="2020上半年收录"></a>2020上半年收录</h1><h2 id="五月上旬收录"><a href="#五月上旬收录" class="headerlink" title="* 五月上旬收录"></a>* 五月上旬收录</h2><h3 id="《蝶恋花·庭院深深深几许》-宋-欧阳修"><a href="#《蝶恋花·庭院深深深几许》-宋-欧阳修" class="headerlink" title="《蝶恋花·庭院深深深几许》-[宋] 欧阳修"></a>《蝶恋花·庭院深深深几许》-[宋] 欧阳修</h3><blockquote>
<p><strong>庭院深深深几许，杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。<br>雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。</strong></p>
</blockquote>
<hr>
<h3 id="《武陵春·风住尘香花已尽》-宋-李清照"><a href="#《武陵春·风住尘香花已尽》-宋-李清照" class="headerlink" title="《武陵春·风住尘香花已尽》-[宋] 李清照"></a>《武陵春·风住尘香花已尽》-[宋] 李清照</h3><blockquote>
<p><strong>风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。<br>闻说双溪春尚好，也拟泛轻舟。只恐双溪舴艋舟，载不动许多愁。</strong></p>
</blockquote>
<hr>
<h3 id="《生查子·元夕》-宋-欧阳修"><a href="#《生查子·元夕》-宋-欧阳修" class="headerlink" title="《生查子·元夕》-[宋] 欧阳修"></a>《生查子·元夕》-[宋] 欧阳修</h3><blockquote>
<p><strong>去年元夜时，花市灯如昼。月上柳梢头，人约黄昏后。<br>今年元夜时，月与灯依旧。不见去年人，泪湿春衫袖。</strong></p>
</blockquote>
<hr>
<h3 id="《钗头凤·红酥手》-宋-陆游"><a href="#《钗头凤·红酥手》-宋-陆游" class="headerlink" title="《钗头凤·红酥手》-[宋] 陆游"></a>《钗头凤·红酥手》-[宋] 陆游</h3><blockquote>
<p><strong>红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。<br>春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！</strong></p>
</blockquote>
<hr>
<h2 id="四月下旬收录"><a href="#四月下旬收录" class="headerlink" title="* 四月下旬收录"></a>* 四月下旬收录</h2><h3 id="《陌上花三首》-宋-苏轼"><a href="#《陌上花三首》-宋-苏轼" class="headerlink" title="《陌上花三首》-[宋] 苏轼"></a>《陌上花三首》-[宋] 苏轼</h3><blockquote>
<ul>
<li><strong>陌上开花蝴蝶飞，江山犹是昔人非</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《贺新郎·甚矣吾衰矣》-宋-辛弃疾"><a href="#《贺新郎·甚矣吾衰矣》-宋-辛弃疾" class="headerlink" title="《贺新郎·甚矣吾衰矣》-[宋] 辛弃疾"></a>《贺新郎·甚矣吾衰矣》-[宋] 辛弃疾</h3><blockquote>
<ul>
<li><strong>我见青山多妩媚，料青山见我，应如是。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《虞美人·雨后同干誉才卿置酒来禽花下作》-宋-叶梦得"><a href="#《虞美人·雨后同干誉才卿置酒来禽花下作》-宋-叶梦得" class="headerlink" title="《虞美人·雨后同干誉才卿置酒来禽花下作》-[宋] 叶梦得"></a>《虞美人·雨后同干誉才卿置酒来禽花下作》-[宋] 叶梦得</h3><blockquote>
<p><strong>落花已作风前舞。又送黄昏雨。晓来庭院半残红。惟有游丝千丈、罥晴空。<br>殷勤花下同携手。更尽杯中酒。美人不用敛蛾眉。我亦多情无奈、酒阑时。</strong></p>
</blockquote>
<hr>
<h3 id="《蝶恋花·春景》-宋-苏轼"><a href="#《蝶恋花·春景》-宋-苏轼" class="headerlink" title="《蝶恋花·春景》-[宋] 苏轼"></a>《蝶恋花·春景》-[宋] 苏轼</h3><blockquote>
<p><strong>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草。<br>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</strong></p>
</blockquote>
<hr>
<h3 id="《东风第一枝·倾国倾城》-宋-吴文英"><a href="#《东风第一枝·倾国倾城》-宋-吴文英" class="headerlink" title="《东风第一枝·倾国倾城》-[宋] 吴文英"></a>《东风第一枝·倾国倾城》-[宋] 吴文英</h3><blockquote>
<p><strong>倾国倾城，非花非雾，春风十里独步。胜如西子妖绕，更比太真澹泞。铅华不御。漫道有、巫山洛浦。似恁地、标格无双，镇锁画楼深处。<br>曾被风、容易送去。曾被月、等闲留住。似花翻使花羞，似柳任从柳妒。不教歌舞。恐化作、彩云轻举。信下蔡、阳城俱迷，看取宋玉词赋。</strong></p>
</blockquote>
<hr>
<h3 id="《洛神赋》-魏晋-曹植"><a href="#《洛神赋》-魏晋-曹植" class="headerlink" title="《洛神赋》-[魏晋] 曹植"></a>《洛神赋》-[魏晋] 曹植</h3><blockquote>
<ul>
<li><strong>翩若惊鸿，婉若游龙，荣曜秋菊，华茂春松。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《相见欢》-五代-李煜"><a href="#《相见欢》-五代-李煜" class="headerlink" title="《相见欢》-[五代] 李煜"></a>《相见欢》-[五代] 李煜</h3><blockquote>
<p><strong>林花谢了春红，太匆匆。无奈朝来寒雨晚来风。<br>胭脂泪，相留醉，几时重。自是人生长恨水长东。</strong></p>
</blockquote>
<hr>
<h3 id="《沈园二首》-宋-陆游"><a href="#《沈园二首》-宋-陆游" class="headerlink" title="《沈园二首》-[宋] 陆游"></a>《沈园二首》-[宋] 陆游</h3><blockquote>
<ul>
<li><strong>城上斜阳画角哀，沈园非复旧池台， 伤心桥下春波绿，曾是惊鸿照影来。</strong> </li>
</ul>
</blockquote>
<hr>
<h3 id="《鹊桥仙·纤云弄巧》-宋-秦观"><a href="#《鹊桥仙·纤云弄巧》-宋-秦观" class="headerlink" title="《鹊桥仙·纤云弄巧》-[宋] 秦观"></a>《鹊桥仙·纤云弄巧》-[宋] 秦观</h3><blockquote>
<p><strong>纤云弄巧，飞星传恨，银汉迢迢暗度。 金风玉露一相逢，便胜却、人间无数。<br>柔情似水，佳期如梦，忍顾鹊桥归路。 两情若是久长时，又岂在、朝朝暮暮。</strong></p>
</blockquote>
<hr>
<h3 id="《乞彩笺歌》-唐-韦庄"><a href="#《乞彩笺歌》-唐-韦庄" class="headerlink" title="《乞彩笺歌》-[唐] 韦庄"></a>《乞彩笺歌》-[唐] 韦庄</h3><blockquote>
<ul>
<li><strong>我有歌诗一千首，磨砻山岳罗星斗。开卷长疑雷电惊，挥毫只怕龙蛇走。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>班班布在时人口，满袖松花都未有。人间无处买烟霞，须知得自神仙手。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>也知价重连城璧，一纸万金犹不惜。薛涛昨夜梦中来，殷勤劝向君边觅。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《山居秋暝》-唐-王维"><a href="#《山居秋暝》-唐-王维" class="headerlink" title="《山居秋暝》-[唐] 王维"></a>《山居秋暝》-[唐] 王维</h3><blockquote>
<p><strong>空山新雨后，天气晚来秋。 明月松间照，清泉石上流。<br>竹喧归浣女，莲动下渔舟。 随意春芳歇，王孙自可留。</strong></p>
</blockquote>
<hr>
<h3 id="《芙蓉楼送辛渐》-唐-王昌龄"><a href="#《芙蓉楼送辛渐》-唐-王昌龄" class="headerlink" title="《芙蓉楼送辛渐》-[唐] 王昌龄"></a>《芙蓉楼送辛渐》-[唐] 王昌龄</h3><blockquote>
<p><strong>寒雨连江夜入吴，平明送客楚山孤。 洛阳亲友如相问，一片冰心在玉壶。</strong></p>
</blockquote>
<hr>
<h2 id="四月中旬收录"><a href="#四月中旬收录" class="headerlink" title="* 四月中旬收录"></a>* 四月中旬收录</h2><h3 id="《无题》-唐-李商隐"><a href="#《无题》-唐-李商隐" class="headerlink" title="《无题》-[唐] 李商隐"></a>《无题》-[唐] 李商隐</h3><blockquote>
<p><strong>照梁初有情，出水旧知名。裙衩芙蓉小，钗茸翡翠轻。<br>锦长书郑重，眉细恨分明。莫近弹棋局，中心最不平。</strong></p>
</blockquote>
<hr>
<h3 id="《乐府-古相思曲》-两汉-佚名"><a href="#《乐府-古相思曲》-两汉-佚名" class="headerlink" title="《乐府.古相思曲》-[两汉] 佚名"></a>《乐府.古相思曲》-[两汉] 佚名</h3><p>　</p>
<blockquote>
<ul>
<li><strong>君似明月我似雾，雾随月隐空留露。<br>君善抚琴我善舞，曲终人离心若堵。<br>只缘感君一回顾，使我思君朝与暮。<br>魂随君去终不悔, 绵绵相思为君苦。<br>相思苦，凭谁诉？遥遥不知君何处。<br>扶门切思君之嘱，登高望断天涯路。</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>十三与君初相识，王侯宅里弄丝竹。<br>只缘感君一回顾，使我思君朝与暮。<br>再见君时妾十五，且为君作霓裳舞。<br>可叹年华如朝露，何时衔泥巢君屋？</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《长命女·春日宴》-五代-冯延巳"><a href="#《长命女·春日宴》-五代-冯延巳" class="headerlink" title="《长命女·春日宴》-[五代] 冯延巳"></a>《长命女·春日宴》-[五代] 冯延巳</h3><blockquote>
<p><strong>春日宴，绿酒一杯歌一遍。再拜陈三愿：一愿郎君千岁，二愿妾身常健，三愿如同梁上燕，岁岁长相见。</strong></p>
</blockquote>
<hr>
<h3 id="《听筝》-唐-李端"><a href="#《听筝》-唐-李端" class="headerlink" title="《听筝》-[唐] 李端"></a>《听筝》-[唐] 李端</h3><blockquote>
<p><strong>鸣筝金粟柱，素手玉房前。欲得周郎顾，时时误拂弦。</strong></p>
</blockquote>
<hr>
<h3 id="《陌上花开，可缓缓归矣》-五代-吴越王"><a href="#《陌上花开，可缓缓归矣》-五代-吴越王" class="headerlink" title="《陌上花开，可缓缓归矣》-[五代] 吴越王"></a>《陌上花开，可缓缓归矣》-[五代] 吴越王</h3><blockquote>
<p><strong>陌上花开，可缓缓归矣</strong></p>
</blockquote>
<hr>
<h3 id="《赠去婢》-唐-崔郊"><a href="#《赠去婢》-唐-崔郊" class="headerlink" title="《赠去婢》-[唐] 崔郊"></a>《赠去婢》-[唐] 崔郊</h3><blockquote>
<p><strong>公子王孙逐后尘，绿珠垂泪滴罗巾。侯门一入深如海，从此萧郎是路人。</strong></p>
</blockquote>
<hr>
<h3 id="《丑奴儿·书博山道中壁》-宋-辛弃疾"><a href="#《丑奴儿·书博山道中壁》-宋-辛弃疾" class="headerlink" title="《丑奴儿·书博山道中壁》-[宋] 辛弃疾"></a>《丑奴儿·书博山道中壁》-[宋] 辛弃疾</h3><blockquote>
<p><strong>少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。<br>而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。</strong></p>
</blockquote>
<hr>
<h3 id="《题都城南庄》-唐-崔护"><a href="#《题都城南庄》-唐-崔护" class="headerlink" title="《题都城南庄》-[唐] 崔护"></a>《题都城南庄》-[唐] 崔护</h3><blockquote>
<p><strong>去年今日此门中，人面桃花相映红。 人面不知何处去，桃花依旧笑春风。</strong></p>
</blockquote>
<hr>
<h3 id="《闺怨》-唐-王昌龄"><a href="#《闺怨》-唐-王昌龄" class="headerlink" title="《闺怨》-[唐] 王昌龄"></a>《闺怨》-[唐] 王昌龄</h3><blockquote>
<p><strong>闺中少妇不知愁，春日凝妆上翠楼。 忽见陌头杨柳色，悔教夫婿觅封侯。</strong></p>
</blockquote>
<hr>
<h3 id="《采薇》-先秦-佚名"><a href="#《采薇》-先秦-佚名" class="headerlink" title="《采薇》-[先秦] 佚名"></a>《采薇》-[先秦] 佚名</h3><blockquote>
<ul>
<li><strong>昔我往矣，杨柳依依。今我来思，雨雪霏霏。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《乌衣巷》-唐-刘禹锡"><a href="#《乌衣巷》-唐-刘禹锡" class="headerlink" title="《乌衣巷》-[唐] 刘禹锡"></a>《乌衣巷》-[唐] 刘禹锡</h3><blockquote>
<p><strong>朱雀桥边野草花，乌衣巷口夕阳斜。 旧时王谢堂前燕，飞入寻常百姓家。</strong></p>
</blockquote>
<hr>
<h3 id="《木兰词·拟古决绝词柬友》-清-纳兰性德"><a href="#《木兰词·拟古决绝词柬友》-清-纳兰性德" class="headerlink" title="《木兰词·拟古决绝词柬友》-[清] 纳兰性德"></a>《木兰词·拟古决绝词柬友》-[清] 纳兰性德</h3><blockquote>
<ul>
<li><strong>人生若只如初见，何事秋风悲画扇。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《青玉案·凌波不过横塘路》-宋-贺铸"><a href="#《青玉案·凌波不过横塘路》-宋-贺铸" class="headerlink" title="《青玉案·凌波不过横塘路》-[宋] 贺铸"></a>《青玉案·凌波不过横塘路》-[宋] 贺铸</h3><blockquote>
<p><strong>凌波不过横塘路。但目送、芳尘去。锦瑟华年谁与度。月桥花院，琐窗朱户。只有春知处。<br>飞云冉冉蘅皋暮。彩笔新题断肠句。若问闲情都几许。一川烟草，满城风絮。梅子黄时雨。</strong></p>
</blockquote>
<hr>
<h3 id="《采桑子·时光只解催人老》-宋-晏殊"><a href="#《采桑子·时光只解催人老》-宋-晏殊" class="headerlink" title="《采桑子·时光只解催人老》-[宋] 晏殊"></a>《采桑子·时光只解催人老》-[宋] 晏殊</h3><blockquote>
<ul>
<li><strong>时光只解催人老，不信多情，长恨离亭，泪滴春衫酒易醒。</strong></li>
</ul>
</blockquote>
<hr>
<h2 id="四月上旬收录"><a href="#四月上旬收录" class="headerlink" title="* 四月上旬收录"></a>* 四月上旬收录</h2><h3 id="《越人歌》-春秋-刘向"><a href="#《越人歌》-春秋-刘向" class="headerlink" title="《越人歌》-[春秋] 刘向"></a>《越人歌》-[春秋] 刘向</h3><blockquote>
<ul>
<li><strong>山有木兮木有枝，心悦君兮君不知。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《白头吟》-汉-卓文君"><a href="#《白头吟》-汉-卓文君" class="headerlink" title="《白头吟》-[汉] 卓文君"></a>《白头吟》-[汉] 卓文君</h3><blockquote>
<ul>
<li><strong>愿得一心人，白头不相离。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《迢迢牵牛星》-汉-佚名"><a href="#《迢迢牵牛星》-汉-佚名" class="headerlink" title="《迢迢牵牛星》-[汉] 佚名"></a>《迢迢牵牛星》-[汉] 佚名</h3><blockquote>
<p><strong>迢迢牵牛星，皎皎河汉女。<br>纤纤擢素手，札札弄机杼。<br>终日不成章，泣涕零如雨；<br>河汉清且浅，相去复几许！<br>盈盈一水间，脉脉不得语。</strong></p>
</blockquote>
<hr>
<h3 id="《蝶恋花·阅尽天涯离别苦》-清-王国维"><a href="#《蝶恋花·阅尽天涯离别苦》-清-王国维" class="headerlink" title="《蝶恋花·阅尽天涯离别苦》-[清] 王国维"></a>《蝶恋花·阅尽天涯离别苦》-[清] 王国维</h3><blockquote>
<ul>
<li><strong>待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="《长相思·一重山》-五代-李煜"><a href="#《长相思·一重山》-五代-李煜" class="headerlink" title="《长相思·一重山》-[五代] 李煜"></a>《长相思·一重山》-[五代] 李煜</h3><blockquote>
<p><strong>一重山，两重山。山远天高烟水寒，相思枫叶丹。<br>菊花开，菊花残。塞雁高飞人未还，一帘风月闲。</strong></p>
</blockquote>
<hr>
<h3 id="《青玉案·元夕》-宋-辛弃疾"><a href="#《青玉案·元夕》-宋-辛弃疾" class="headerlink" title="《青玉案·元夕》-[宋] 辛弃疾"></a>《青玉案·元夕》-[宋] 辛弃疾</h3><blockquote>
<p><strong>东风夜放花千树。更吹落、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。<br>蛾儿雪柳黄金缕。笑语盈盈暗香去。众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。</strong></p>
</blockquote>
<hr>
<h3 id="《醉花阴·薄雾浓云愁永昼》-宋-李清照"><a href="#《醉花阴·薄雾浓云愁永昼》-宋-李清照" class="headerlink" title="《醉花阴·薄雾浓云愁永昼》-[宋] 李清照"></a>《醉花阴·薄雾浓云愁永昼》-[宋] 李清照</h3><blockquote>
<p><strong>薄雾浓云愁永昼，瑞脑消金兽。佳节又重阳，玉枕纱厨，半夜凉初透。<br>东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。</strong></p>
</blockquote>
<hr>
<h3 id="《山亭夏日》-唐-高骈"><a href="#《山亭夏日》-唐-高骈" class="headerlink" title="《山亭夏日》-[唐] 高骈"></a>《山亭夏日》-[唐] 高骈</h3><blockquote>
<p><strong>绿树阴浓夏日长，楼台倒影入池塘。<br>水晶帘动微风起，满架蔷薇一院香。</strong></p>
</blockquote>
<hr>
<h3 id="《书湖阴先生壁》-宋-王安石"><a href="#《书湖阴先生壁》-宋-王安石" class="headerlink" title="《书湖阴先生壁》-[宋] 王安石"></a>《书湖阴先生壁》-[宋] 王安石</h3><blockquote>
<p><strong>茅檐长扫净无苔，花木成畦手自栽。<br>一水护田将绿绕，两山排闼送青来。</strong></p>
</blockquote>
<hr>
<h3 id="《鹧鸪天·彩袖殷勤捧玉钟》-宋-晏几道"><a href="#《鹧鸪天·彩袖殷勤捧玉钟》-宋-晏几道" class="headerlink" title="《鹧鸪天·彩袖殷勤捧玉钟》-[宋] 晏几道"></a>《鹧鸪天·彩袖殷勤捧玉钟》-[宋] 晏几道</h3><blockquote>
<p><strong>彩袖殷勤捧玉钟。当年拚却醉颜红。舞低杨柳楼心月，歌尽桃花扇影风。<br>从别后，忆相逢。几回魂梦与君同。今宵剩把银釭照，犹恐相逢是梦中。</strong></p>
</blockquote>
<hr>
<h3 id="《上邪》-汉-佚名"><a href="#《上邪》-汉-佚名" class="headerlink" title="《上邪》-[汉] 佚名"></a>《上邪》-[汉] 佚名</h3><blockquote>
<p><strong>上邪，<br>我欲与君相知，<br>长命无绝衰。<br>山无陵，<br>江水为竭。<br>冬雷震震，<br>夏雨雪。<br>天地合，<br>乃敢与君绝。</strong></p>
</blockquote>
<hr>
<h3 id="《晓出净慈寺送林子方》-宋-杨万里"><a href="#《晓出净慈寺送林子方》-宋-杨万里" class="headerlink" title="《晓出净慈寺送林子方》-[宋] 杨万里"></a>《晓出净慈寺送林子方》-[宋] 杨万里</h3><blockquote>
<p><strong>毕竟西湖六月中，风光不与四时同。<br>接天莲叶无穷碧，映日荷花别样红。</strong></p>
</blockquote>
<hr>
<h3 id="《一剪梅》-明-唐寅"><a href="#《一剪梅》-明-唐寅" class="headerlink" title="《一剪梅》-[明] 唐寅"></a>《一剪梅》-[明] 唐寅</h3><blockquote>
<p><strong>雨打梨花深闭门，忘了青春，误了青春。赏心乐事共谁论？花下销魂，月下销魂。<br>愁聚眉峰尽日颦，千点啼痕，万点啼痕。晓看天色暮看云，行也思君，坐也思君。</strong></p>
</blockquote>
<hr>
<h3 id="《清平调·其一》-唐-李白"><a href="#《清平调·其一》-唐-李白" class="headerlink" title="《清平调·其一》-[唐] 李白"></a>《清平调·其一》-[唐] 李白</h3><blockquote>
<p><strong>云想衣裳花想容，春风拂槛露华浓。<br>若非群玉山头见，会向瑶台月下逢。</strong></p>
</blockquote>
<hr>
<h3 id="《江城子·乙卯正月二十日夜记梦》-宋-苏轼"><a href="#《江城子·乙卯正月二十日夜记梦》-宋-苏轼" class="headerlink" title="《江城子·乙卯正月二十日夜记梦》-[宋] 苏轼"></a>《江城子·乙卯正月二十日夜记梦》-[宋] 苏轼</h3><blockquote>
<p><strong>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。<br>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>佳句收录 古诗丽词</category>
      </categories>
      <tags>
        <tag>语言之美</tag>
      </tags>
  </entry>
  <entry>
    <title>语言之美-新句美文</title>
    <url>/2021/02/01/%E8%AF%AD%E8%A8%80%E4%B9%8B%E7%BE%8E-%E6%96%B0%E5%8F%A5%E7%BE%8E%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>佚名</p>
</blockquote>
<ul>
<li><p><strong>那我们就让敌人有来无回，血流成河，让他们知道这是可怕的一夜。</strong></p>
</li>
<li><p><strong>我们的奋斗只有两种结果，要么敌人踏着我们的尸骨过去，要么我们踏着敌人的尸骨过去。</strong></p>
</li>
<li><p><strong>当我们遭遇敌人，遭遇苦难时，我们必须反抗，否则他们会踩着我们的头颅拔除血淋淋的剑，唾弃着说，：看！这就是奴隶！</strong></p>
</li>
</ul>
<hr>
<blockquote>
<p>佚名</p>
</blockquote>
<ul>
<li><strong>生如亚当，却没有伊甸园的庇护。在这无情无义的世界，我势如撒旦。（Born like Adam, but I had no refuge in the Garden of Eden. In the heartless and unjust world, I am like Satan.）</strong></li>
</ul>
<hr>
<blockquote>
<p>《敌基督者》-尼采</p>
</blockquote>
<ul>
<li><strong>谁终将声震人间，必长久深自缄默。<br>谁终将点燃闪电，必长久如云漂泊。</strong></li>
</ul>
<hr>
<blockquote>
<p>我</p>
</blockquote>
<ul>
<li><strong>如果地球是平的<br>你向西，我往东，一起跌入这世界尽头<br>从此世界是圆的，我们终会重逢</strong></li>
</ul>
<hr>
<blockquote>
<p>《随性所欲》</p>
</blockquote>
<ul>
<li><strong>我们花一辈子时间，等待父母给我们道歉；他们花一辈子时间等我们说谢谢，而我们都得不到想要的。</strong></li>
</ul>
<hr>
<blockquote>
<p>佚名</p>
</blockquote>
<ul>
<li><strong>你写了成百上千条微博、日志或朋友圈，有些是写给专门的人看的。但往往这个人看不到，不会看，也不想看。直到有一天，另一个不相关的人突然跟你说：你写的所有东西我都看完了，好心疼你呀，啊哈——你看，真正在乎你的人读的不是你的某条心情，他们想读的，是你的整个人生。</strong></li>
</ul>
<a id="more"></a>
<hr>
<blockquote>
<p>某位抑郁症患者-佚名</p>
</blockquote>
<ul>
<li><strong>我做了自己最大的抗争，我在无数次放弃自己的边缘拯救自己，也许在别人的世界里我什么也不是，但在我自己的世界里，我是自己的英雄。</strong></li>
</ul>
<hr>
<blockquote>
<p>佚名</p>
</blockquote>
<ul>
<li><strong>如今我渴望的爱情，不是牵着手一起面对无可预知的未来；不是花前月下浪漫的拥吻；也不是因为寂寞而随便找个人来陪。<br>而是当我面无表情穿梭在人群的时候，不知道会走多远，但知道在路的尽头我可以和你遇见。你张开双臂，来接纳我一身风霜雨雪，心疼地问我一路走来辛不辛苦，累不累。<br>我不言也不语，只把最温柔的笑给你</strong></li>
</ul>
<hr>
<blockquote>
<p>《道别》-佚名</p>
</blockquote>
<p><strong>我对蝉说：<br>他日再见 要待来年<br>蝉对我说：<br>他日重逢 要等来生</strong></p>
<hr>
<blockquote>
<p>《热风》-鲁迅</p>
</blockquote>
<ul>
<li><strong>愿中国青年都摆脱冷气,只是向上走,不必听自暴自弃者流的话。能做事的做事,能发声的发声.有一分热,发一分光,就令萤火一般,也可以在黑暗里发一点光,不必等候炬火。</strong></li>
<li><strong>此后如竟没有炬火：我便是唯一的光。</strong></li>
<li><strong>倘若有了炬火,出了太阳,我们自然心悦诚服的消失,不但毫无不平,而且还要随喜赞美这炬火或太阳；因为他照了人类,连我都在内.　　我又愿中国青年都只是向上走,不必理会这冷笑和暗箭。</strong></li>
</ul>
<hr>
<blockquote>
<p>《终了》-张九南</p>
</blockquote>
<ul>
<li><strong>终是庄周梦了蝶，你是恩赐也是劫。<br>终是李白醉了酒，你是孤独也是愁。<br>终是荆轲刺了秦，一代君王一世民。<br>终是妲己祸了国，万里江山似蹉跎。<br>终是玉环停了曲，无人再懂琵琶语。<br>终是韩信放下枪，你是宿命也是伤。<br>终是悟空成了佛，你一堕落便是魔。<br>终是霸王别了姬，弃了江山负了你。<br>终是后裔断了箭，此生注定难相见。<br>终是评书已截断，从此告别定场诗。</strong></li>
</ul>
<hr>
<blockquote>
<p>我</p>
</blockquote>
<ul>
<li><strong>照片是光与影的悦动，纠缠着喜或悲的回忆</strong></li>
</ul>
<hr>
<blockquote>
<p>《波兰来客》-北岛</p>
</blockquote>
<ul>
<li><strong>年轻时我们都有梦想，关于文字，关于爱情，关于穿越世界的旅行。现在我们夜深饮酒杯子撞在一起，听到的都是梦破碎的声音。</strong></li>
</ul>
<hr>
<blockquote>
<p>《红玫瑰与白玫瑰》-张爱玲 </p>
</blockquote>
<ul>
<li><strong>也许每一个男子全都有过这样的两个女人，至少两个。娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是“床前明月光”；娶了白玫瑰，白的便是衣服上的一粒饭粘子，红的却是心口上的一颗朱砂痣。</strong></li>
</ul>
<hr>
<blockquote>
<p>《在细雨中呼喊》-余华 </p>
</blockquote>
<ul>
<li><strong>死亡不是失去生命，而是走出了时间。</strong></li>
</ul>
<hr>
<blockquote>
<p>《生命最后的读书会》-[美] 威尔·施瓦尔贝 </p>
</blockquote>
<ul>
<li><strong>假如你不愿祝福他的王国，那么不要为之祈祷。假如你愿意，不能只靠祈祷，还必须为之努力。-《天国降临》</strong></li>
</ul>
<hr>
<blockquote>
<p>《江海共余生》-春和</p>
</blockquote>
<ul>
<li><strong>山河远阔，人间星河，无一是你，无一不是你。</strong></li>
</ul>
<hr>
<blockquote>
<p>《十里红妆女儿梦》-何晓道</p>
</blockquote>
<ul>
<li><strong>待我长发及腰，少年娶我可好？待你青丝绾正，铺十里红妆可愿？ 却怕长发及腰，少年倾心他人。待你青丝绾正，笑看君怀她笑颜。时待我发齐腰长，愿与梦郎诉衷肠。半生缠绵报君享，此情绵绵意长长。时待我发齐腰长，轻舞霓裳意飞扬。襄王神女应无恙，巫山云雨梦得度偿。时待我发齐腰长，红颜老去珠也黄。</strong></li>
</ul>
<hr>
<blockquote>
<p>《思念往昔》-张小娴</p>
</blockquote>
<ul>
<li><strong>我没有很刻意地去想念你，因为我知道遇到了就应该感恩，路过了就应该释怀。我只是在很多个小瞬间想起你。比如，一部电影，一首歌，一句歌词，一条马路和无数个闭上眼的瞬间。</strong></li>
</ul>
<hr>
<blockquote>
<p>《后来》-2017年刘若英演唱会后，出自网络</p>
</blockquote>
<p><strong>初闻不知曲中意，再闻已是曲中人。<br>既然已是曲中人，何必再听曲中曲。<br>曲中轻忆梦中人，梦醒时分叹红尘。<br>曲终人散梦已醒，何处再寻梦中人。<br>梦中合唱凤求凰，梦醒独奏离别赋。<br>即知曲人存于梦，何故执于曲外人。<br>多少痴梦多少等，难诉痴情曲中人。<br>一萧一页红尘事，一弦一曲了人生。<br>既然已是曲中人，何必再悟曲中意。<br>不愿再做曲中人，奈何越听越沉沦。<br>曲中曲，人中人，曲散人终离，曲终人散早成空。<br>一曲肝肠断，天涯何处觅知音。</strong></p>
<hr>
<blockquote>
<p>《当幸福来敲门》-电影</p>
</blockquote>
<ul>
<li><strong>当人们做不到一些事情的时候，他们就会对你说你也同样不可能。如果你有梦想，就去捍卫它。</strong></li>
</ul>
<hr>
<blockquote>
<p>《寄生虫》影评-Hong-King改编自网络</p>
</blockquote>
<ul>
<li><strong>有人说电影《寄生虫》太过灰暗，描述了穷富之间难以跨越的鸿沟，书写了生而为人难以逃脱的宿命。但这是阶级的悲剧吗？我更倾向于这是选择的悲剧，亦是悲剧的选择。他们本可以选择上进、勤恳、沟通，却沉沦于寄生和懒惰，暴力和杀戮。生活不是永恒的暴雨倾盆，总有阳光灿烂的时候，但这时候，就要看你如何选择。是躲在屋里仇视外面的阳光，还是冲到阳光下，努力地活一把。</strong></li>
</ul>
<hr>
<blockquote>
<p>《Like That》-网易云评论</p>
</blockquote>
<ul>
<li><strong>我会变得更好，因为你，但不是为了你。</strong></li>
</ul>
<hr>
<blockquote>
<p>《记得》-网易云评论</p>
</blockquote>
<ul>
<li><strong>无论我们以后生疏成什么样子，请记得曾经我对你的好是真的。剩下的路就不陪你走了，要照顾好自己，不是每个人都是我，三生有幸，遇见你纵使悲凉也是情。</strong></li>
</ul>
<hr>
<blockquote>
<p>《被讨厌的勇气》-[日] 岸见一郎/古贺史健  </p>
</blockquote>
<ul>
<li><strong>在阿德勒眼中，理想的人际关系大概是“我爱你，但与你无关”。他认为每个人的课题都是分离又独特的。我怎么爱你，这是我的课题，而你要不要接受我的爱，这是你的课题。</strong></li>
</ul>
<hr>
<blockquote>
<p>摘自网络</p>
</blockquote>
<ul>
<li><p><strong>有人说，林深时见鹿，海蓝时见鲸，梦醒时见你。可实际，林深时起雾，海蓝时浪涌，梦醒时夜续。但终究，鹿踏雾而来，鲸随浪而起。你没回头又怎知我不在？</strong></p>
</li>
<li><p><strong>你认为的完美爱情是从一而终，而现实中的完美爱情，更像是和生活的握手言和。永远不要说永远。</strong></p>
</li>
<li><p><strong>我永远喜欢你，不是说我会十年二十年一辈子都喜欢你，而是指，我这一刻喜欢你的程度，让我有勇气说出来我永远喜欢你。</strong></p>
</li>
<li><p><strong>过程才是生命，两端都是死亡。</strong></p>
</li>
<li><p><strong>每当有人问起，为什么我不恋爱的时候，我都以麻烦为由搪塞过去。又有人开始问我到底喜欢过谁没有，我也轻描淡写地表示否定。无数的朋友告诉我，或许是你还没碰到过真正喜欢的人吧，我却没法开口告诉他们，其实我曾经碰到过，碰得太早，以至于我没来得及分清，也没来得及弄明白。</strong></p>
</li>
<li><p><strong>遗憾吗？那么喜欢连张合影都没有</strong></p>
</li>
<li><p><strong>没人嘲笑你的梦想，他们只是嘲笑你的实力</strong></p>
</li>
<li><p><strong>其实我也是很羡慕别的小女生收到花，收到唇膏，收到各种各样的惊喜，我嘴上说，反正我都买得起，但在心里还是偷偷羡慕过的，所以希望我的恋人，拜托拜托，送花给我，偷偷准备热门色号的唇膏给我，摸摸我的头，天冷的时候把我的手放在你的口袋里，俗气而又热烈的喜欢我。</strong></p>
</li>
<li><p><strong>和你一起环游世界拍照，就是一口气做了三件最爱的事情。</strong> —#孔维与诗苑#</p>
</li>
<li><p><strong>看你周围，你未来另一半此时正在某个地方，可能坐计程车、看小说、做数学题，收到情书、烹饪、身处旅途、阴天躲在被子里哭、学习怎么打扮、喂猫、给大狗洗澡。就在现在，就在此时此刻，未来注定要和你在一起的那个人，正在努力制造着你们一起躺在床上的那无数个夜晚里准备讲给你的回忆和故事。</strong>—博主:#小羊爱吃酱肘子#</p>
</li>
<li><p><strong>温柔仅供参考，一切请以生气时间为准</strong></p>
</li>
<li><p><strong>我是檐上三寸雪，你是人间惊鸿客</strong></p>
</li>
<li><p><strong>去做你害怕的事，最后你会发现：其实不过如此。</strong></p>
</li>
<li><p><strong>把欺负你的人打疼，一次就够了。</strong></p>
</li>
<li><p><strong>苦难就是苦难，是我们自己足够坚强挺过了苦难，是我们自己从苦难中不断成长。</strong></p>
</li>
<li><p><strong>虽然也会有数不尽的悲伤，但我终将与你相遇</strong></p>
</li>
</ul>
<hr>
<blockquote>
<p>Hong-King</p>
</blockquote>
<ul>
<li><strong>我曾经害怕死亡，有太多人类的奇迹是我看不到的，但我没发现同时我也是幸运的，这个时代本身就有很多奇迹等着我们去创造。</strong></li>
</ul>
]]></content>
      <categories>
        <category>佳句收录 新句美文</category>
      </categories>
      <tags>
        <tag>语言之美</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔密码(Hill Cipher)的C++实现</title>
    <url>/2021/04/10/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81(Hill%20Cipher)%E7%9A%84C++%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>——————-&lt;希尔密码(MOD27)&gt;程序说明——————-<br>该程序目前只接受小写英文加密讯息(支持空格)!<br>每次运行程序，密钥都会改变!<br>该程序相较python版本有所删减，减小了码符集大小，但完善了密钥矩阵的生成条件，增强了安全性。<br><strong><strong><strong><strong>****</strong></strong></strong></strong>博客网址<strong><strong><strong><strong>****</strong></strong></strong></strong><br>欢迎访问：<a href="https://hong-king.github.io/">https://hong-king.github.io/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">All rights reserved by Liu Junhong</span><br><span class="line">Reference books: 百度百科-希尔密码 、https://www.doc88.com/p-58447325494757.html)</span><br><span class="line">Completion time：2021-4-10</span><br><span class="line">*/</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;math.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int p[9]; //P用于储存密钥矩阵</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Designed by 刘俊宏：All rights reserved"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Reference books: 百度百科-希尔密码 、https://www.doc88.com/p-58447325494757.html"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Completion time：2021-4-6"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Last modification time ：2021-4-10"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"-------------------&lt;希尔密码(MOD27)&gt;程序说明-------------------"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"该程序目前只接受小写英文加密讯息(支持空格)!"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"每次运行程序，密钥都会改变!"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"该程序相较python版本有所删减，减小了码符集大小，但完善了密钥矩阵的生成条件，增强了安全性。"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"********************博客网址********************"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"欢迎访问：https://hong-king.github.io/"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"************************************************"</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------------------------------------"</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    生成符合条件的3*3随机密钥矩阵</span><br><span class="line">    */</span><br><span class="line">    int num;</span><br><span class="line">    srand((int)time(0));   //产生随机种子,把0换成NULL也行</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 9; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p[i] = rand()%27+1;  //[1,53]</span><br><span class="line">            &#125;</span><br><span class="line">            num = p[0]*p[4]*p[8] + p[1]*p[5]*p[6] + p[2]*p[3]*p[7] - p[2]*p[4]*p[6] - p[1]*p[3]*p[8] - p[0]*p[5]*p[7];</span><br><span class="line">    &#125;<span class="keyword">while</span>(num%3 == 0);</span><br><span class="line">    cout &lt;&lt; <span class="string">"密钥："</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 9; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    求逆矩阵</span><br><span class="line">    */</span><br><span class="line">    int num_mo;</span><br><span class="line">    <span class="keyword">for</span> (int i = 1; i &lt; 10000; i++)&#123;  //(i &lt; 10000)存在BUG隐患</span><br><span class="line">        <span class="keyword">if</span> ( (num*i)%27 == 1 || (num*i)%27 == -26 )&#123;</span><br><span class="line">            num_mo = i;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int I_p[9]; //P用于储存密钥的逆矩阵（转译矩阵）</span><br><span class="line"></span><br><span class="line">    I_p[0] = (((p[4]*p[8] - p[5]*p[7])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[3] = (((p[5]*p[6] - p[3]*p[8])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[6] = (((p[3]*p[7] - p[4]*p[6])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[1] = (((p[2]*p[7] - p[1]*p[8])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[4] = (((p[0]*p[8] - p[2]*p[6])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[7] = (((p[1]*p[6] - p[0]*p[7])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[2] = (((p[1]*p[5] - p[2]*p[4])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[5] = (((p[2]*p[3] - p[0]*p[5])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    I_p[8] = (((p[0]*p[4] - p[1]*p[3])*num_mo)%27 +27)%27;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    读取需要加密的信息</span><br><span class="line">    */</span><br><span class="line">    string aaa;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入需要加密的信息(只能包含空格和小写字母)："</span>;</span><br><span class="line">    getline(cin,aaa);   //getline用于读取整行数据</span><br><span class="line">    int g = aaa.length(); // 原始信息字数</span><br><span class="line">    int z = 3 - g%3; // 需要扩充的字数</span><br><span class="line">    <span class="keyword">if</span> (z == 3)</span><br><span class="line">        z = 0;</span><br><span class="line">    int g_z = g + z;  //扩充后的字数</span><br><span class="line">    int g_z_s = g_z / 3;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    将加密的信息转换成密文</span><br><span class="line">    */</span><br><span class="line">    int information[g_z] = &#123;0&#125;;</span><br><span class="line">    <span class="keyword">for</span> (int i=0; i &lt;= (g-1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (int(aaa[i])==32)</span><br><span class="line">            information[i] = 0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (int(aaa[i])&gt;=97 &amp;&amp; int(aaa[i])&lt;=122)</span><br><span class="line">        &#123;</span><br><span class="line">            information[i] = int(aaa[i]) - 96;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">"出现违法字符！"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int information_copy[g_z] = &#123;0&#125;;</span><br><span class="line">    <span class="keyword">for</span> (int i=0; i &lt;= (g_z_s-1); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            information_copy[i*3+0] = (information[i*3+0]*p[0] + information[i*3+1]*p[1] + information[i*3+2]*p[2])%27;</span><br><span class="line">            information_copy[i*3+1] = (information[i*3+0]*p[3] + information[i*3+1]*p[4] + information[i*3+2]*p[5])%27;</span><br><span class="line">            information_copy[i*3+2] = (information[i*3+0]*p[6] + information[i*3+1]*p[7] + information[i*3+2]*p[8])%27;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt; <span class="string">"密文："</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i=0; i &lt;= (g_z-1); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (information_copy[i]==0)</span><br><span class="line">                cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (information_copy[i]&gt;=1 &amp;&amp; information_copy[i]&lt;=26)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; char(information_copy[i]+96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        解码</span><br><span class="line">        */</span><br><span class="line">        int information_copy_copy[g_z] = &#123;0&#125;;</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i &lt;= (g_z_s-1); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                information_copy_copy[i*3+0] = (information_copy[i*3+0]*I_p[0] + information_copy[i*3+1]*I_p[1] + information_copy[i*3+2]*I_p[2])%27;</span><br><span class="line">                information_copy_copy[i*3+1] = (information_copy[i*3+0]*I_p[3] + information_copy[i*3+1]*I_p[4] + information_copy[i*3+2]*I_p[5])%27;</span><br><span class="line">                information_copy_copy[i*3+2] = (information_copy[i*3+0]*I_p[6] + information_copy[i*3+1]*I_p[7] + information_copy[i*3+2]*I_p[8])%27;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (information_copy_copy[i*3+0]&lt;0)</span><br><span class="line">                    information_copy_copy[i*3+0] = information_copy_copy[i*3+0] + 27;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (information_copy_copy[i*3+1]&lt;0)</span><br><span class="line">                    information_copy_copy[i*3+1] = information_copy_copy[i*3+1] + 27;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (information_copy_copy[i*3+2]&lt;0)</span><br><span class="line">                    information_copy_copy[i*3+2] = information_copy_copy[i*3+2] + 27;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="string">"明文："</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i=0; i &lt;= (g_z-1); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (information_copy_copy[i]==0)</span><br><span class="line">                cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (information_copy_copy[i]&gt;=1 &amp;&amp; information_copy_copy[i]&lt;=26)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; char(information_copy_copy[i]+96);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Designed by 刘俊宏：All rights reserved</span><br><span class="line">Reference books: 百度百科-希尔密码 、https://www.doc88.com/p-58447325494757.html</span><br><span class="line">Completion time：2021-4-6</span><br><span class="line">Last modification time ：2021-4-10</span><br><span class="line">-------------------&lt;希尔密码(MOD27)&gt;程序说明-------------------</span><br><span class="line">该程序目前只接受小写英文加密讯息(支持空格)!</span><br><span class="line">每次运行程序，密钥都会改变!</span><br><span class="line">该程序相较python版本有所删减，减小了码符集大小，但完善了密钥矩阵的生成条件，增强了安全性。</span><br><span class="line">********************博客网址********************</span><br><span class="line">欢迎访问：https://hong-king.github.io/</span><br><span class="line">************************************************</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">密钥：</span><br><span class="line">1 14 7 21 19 27 13 10 15</span><br><span class="line">请输入需要加密的信息(只能包含空格和小写字母)：asd dfds</span><br><span class="line">密文：</span><br><span class="line">ydtqvv mz</span><br><span class="line">明文：</span><br><span class="line">asd dfds</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>C++ 问题解决</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>元胞自动机在模拟森林野火的应用（Matlab实现）</title>
    <url>/2021/02/04/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9C%A8%E6%A8%A1%E6%8B%9F%E6%A3%AE%E6%9E%97%E9%87%8E%E7%81%AB%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Matlab%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">close;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">n = 300;     %元胞矩阵大小</span><br><span class="line">Plight = 0.000001; Pgrowth = 0.001;</span><br><span class="line">UL = [n 1:n-1];</span><br><span class="line">DR = [2:n 1];</span><br><span class="line">veg = zeros(n,n);        %初始化</span><br><span class="line">% The value of veg:</span><br><span class="line">% empty == 0  </span><br><span class="line">% burning == 1</span><br><span class="line">% green == 2</span><br><span class="line">imh = image(cat(3,veg,veg,veg));</span><br><span class="line">m=annotation(<span class="string">'textbox'</span>,[0.1,0.1,0.1,0.1],<span class="string">'LineStyle'</span>,<span class="string">'-'</span>,<span class="string">'LineWidth'</span>,1,<span class="string">'String'</span>,<span class="string">'123'</span>);</span><br><span class="line"><span class="keyword">for</span> i = 1:100000</span><br><span class="line">    sum = (veg(UL,:) == 1) + (veg(:,UL) == 1) + (veg(DR,:) == 1) + (veg(:,DR) == 1);</span><br><span class="line">    %根据规则更新森林矩阵：树 = 树 - 着火的树 + 新生的树</span><br><span class="line">    veg = 2 * (veg == 2) - ( (veg == 2) &amp; (sum &gt; 0 | (rand(n,n) &lt; Plight)) ) + 2 * ( (veg == 0) &amp; rand(n,n) &lt; Pgrowth);</span><br><span class="line">    a=find(veg==2);</span><br><span class="line">    b=find(veg==1);</span><br><span class="line">    aa=length(a);</span><br><span class="line">    bb=length(b);</span><br><span class="line">    shu(i)=aa;</span><br><span class="line">    fire(i)=bb*30;</span><br><span class="line">    <span class="keyword">if</span> (bb&gt;=0&amp;&amp;bb&lt;=10)</span><br><span class="line">        str1=<span class="string">'森林正常'</span>;</span><br><span class="line">    elseif (bb&gt;10&amp;&amp;bb&lt;=100)</span><br><span class="line">        str1=<span class="string">'火灾发展'</span>;</span><br><span class="line">    elseif (bb&gt;100)</span><br><span class="line">        str1=<span class="string">'森林大火'</span>;</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> ((aa&gt;48000)||(bb&gt;=10))</span><br><span class="line">        str2=<span class="string">'火灾预警：红色预警'</span>;</span><br><span class="line">    elseif (aa&gt;42000&amp;&amp;aa&lt;=48000)</span><br><span class="line">        str2=<span class="string">'火灾预警：黄色预警'</span>;</span><br><span class="line">    elseif (aa&gt;35000&amp;&amp;aa&lt;=42000)</span><br><span class="line">        str2=<span class="string">'火灾预警：蓝色预警'</span>;</span><br><span class="line">    elseif (aa&gt;=0&amp;&amp;aa&lt;=35000)</span><br><span class="line">        str2=<span class="string">'火灾预警：安全'</span>;</span><br><span class="line">    end </span><br><span class="line">    str=[str1 10 str2];</span><br><span class="line">    <span class="built_in">set</span>(imh, <span class="string">'cdata'</span>, cat(3, (veg == 1), (veg == 2), zeros(n)) )</span><br><span class="line">    drawnow</span><br><span class="line">    figure(2)</span><br><span class="line">    delete(m)</span><br><span class="line">    plot(shu);</span><br><span class="line">    hold on</span><br><span class="line">    plot(fire);</span><br><span class="line">    legend([<span class="string">'绿树的数量'</span>,num2str(aa)],[<span class="string">'火的数量'</span>,num2str(bb)]);</span><br><span class="line">    title([<span class="string">'时间T='</span>,num2str(i),<span class="string">'天'</span>]);</span><br><span class="line">    m=annotation(<span class="string">'textbox'</span>,[0.15,0.8,0.1,0.1],<span class="string">'LineStyle'</span>,<span class="string">'-'</span>,<span class="string">'LineWidth'</span>,1,<span class="string">'String'</span>,str);</span><br><span class="line">    hold off</span><br><span class="line">%     pause(0.0001)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Matlab 算法实现</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>泊松分布的卡方检验（Matlab实现）</title>
    <url>/2021/02/02/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E7%9A%84%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C%EF%BC%88Matlab%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">r = expcdf(x,2.5)*100; %负指数分布(累计)</span><br><span class="line">P = poisscdf(x,2.1)*100; %泊松分布(累计)</span><br><span class="line">r = exppdf(x,2.5)*100; %负指数分布</span><br><span class="line">P = poisspdf(x,2.1)*100; %泊松分布</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">x = 0:1:6;</span><br><span class="line">y = poisspdf(x,2.1)*100; %泊松分布的理论值</span><br><span class="line">plot(x,y)</span><br><span class="line">hold on;</span><br><span class="line">x = 0:1:6;</span><br><span class="line">y1 = [10 28 29 16 10 6 1]; %泊松分布的实际值</span><br><span class="line">plot(x,y1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[h,p,stats] = chi2gof(x, <span class="string">'ctrs'</span>, x, <span class="string">'frequency'</span>, y1, <span class="string">'expected'</span>, y, <span class="string">'nparams'</span>,0) %卡方检验</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Matlab 算法实现</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>负指数分布的卡方检验（Matlab实现）</title>
    <url>/2021/02/02/%E8%B4%9F%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E7%9A%84%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C%EF%BC%88Matlab%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">r = expcdf(x,2.5)*100; %负指数分布(累计)</span><br><span class="line">P = poisscdf(x,2.1)*100; %泊松分布(累计)</span><br><span class="line">r = exppdf(x,2.5)*100; %负指数分布</span><br><span class="line">P = poisspdf(x,2.1)*100; %泊松分布</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">x = 0:1:6;</span><br><span class="line">y1 = [38,25,17,9,6,5,0]; %负指数分布实际值</span><br><span class="line">plot(x,y1)</span><br><span class="line">hold on;</span><br><span class="line">x = 0:1:6;</span><br><span class="line">y2 = exppdf(x,2.5)*100; %负指数分布理论值</span><br><span class="line">plot(x,y2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[h,p,stats] = chi2gof(x, <span class="string">'ctrs'</span>, x, <span class="string">'frequency'</span>, y1, <span class="string">'expected'</span>, y2, <span class="string">'nparams'</span>,0) %卡方检验</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Matlab 算法实现</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法的Matlab实现</title>
    <url>/2021/02/02/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84Matlab%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>遗传算法主函数</p>
</blockquote>
<p><strong>k1</strong>为遗传进化总代数，<strong>k2</strong>为计算机显示控制数<br><strong>m</strong>为群体规模，<strong>n</strong>为染色体长度，<strong>t</strong>为交叉算子选择位<br><strong>pc</strong>为交叉概率，<strong>pm</strong>为变异概率，<strong>[a,b]</strong>为解码取值范围<br><strong>A</strong>为进化结束后群体，<strong>xx</strong>为对应解码，<strong>yy</strong>为目标函数值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [A,xx,yy] = genetic_algorithm(k1,k2,m,n,t,pc,pm,a,b)</span><br><span class="line">%&#123;</span><br><span class="line">k1为遗传进化总代数，k2为计算机显示控制数</span><br><span class="line">m为群体规模，n为染色体长度，t为交叉算子选择位</span><br><span class="line">pc为交叉概率，pm为变异概率，[a,b]为解码取值范围</span><br><span class="line">A为进化结束后群体，xx为对应解码，yy为目标函数值</span><br><span class="line">%&#125;</span><br><span class="line">A = round(rand(m,n)); %生成遗传基因</span><br><span class="line">% round()函数用于取最接近的整数</span><br><span class="line">% rand())函数用于产生由在(0, 1)之间均匀分布的随机数组成的数组。</span><br><span class="line"><span class="keyword">for</span> k = 1:k1</span><br><span class="line">    [g,f] = fun_fitness(A,n,a,b);%计算适应度函数</span><br><span class="line">    A = fun_selection(A,g,m,n);%选择算子</span><br><span class="line">    A = fun_crossover(A,t,n,pc);%交叉算子</span><br><span class="line">    A = fun_mutation(A,pm); %变异算子</span><br><span class="line">    <span class="keyword">if</span> mod(k,k2) == 0</span><br><span class="line">        [xx,yy] = fun_value(A,n,a,b); %函数值计算</span><br><span class="line">        k</span><br><span class="line">        dispx = xx<span class="string">'</span></span><br><span class="line"><span class="string">        dispy = yy'</span></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">[xx,yy] = fun_value(A,n,a,b);</span><br><span class="line">%[A,xx,yy] = genetic_algorithm(500,100,10,17,9,0.8,0.01,0,10)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<hr>
<blockquote>
<p>适应度函数，用于计算A中各染色体的个体适应度</p>
</blockquote>
<p><strong>n</strong>为染色体长度，<strong>[a,b]</strong>为变量取值范围，<strong>g</strong>为适应值，<strong>f</strong>为目标函数值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [g,f] = fun_fitness(A,n,a,b)</span><br><span class="line">%适应度函数，用于计算A中各染色体的个体适应度</span><br><span class="line">%n为染色体长度，[a,b]为变量取值范围，g为适应值，f为目标函数值</span><br><span class="line">[p,~] = size(A);</span><br><span class="line">f = zeros(p,1);</span><br><span class="line">g = zeros(p,1);</span><br><span class="line">vx = fun_decode(A,n,a,b); % 解码操作</span><br><span class="line"><span class="keyword">for</span> i = 1:p</span><br><span class="line">     x = vx(i);</span><br><span class="line">     f(i,1) = 8*sin(5*x)+5*cos(4*x); %目标函数值</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fmin = min(f);</span><br><span class="line"><span class="keyword">for</span> i = 1:p</span><br><span class="line">    g(i,1) = f(i)-fmin+1; %适应度函数值</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>选择算子</p>
</blockquote>
<p>按个体适应度F从种群A中选取m个形成种群B，<strong>n</strong>为基因编码长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> B = fun_selection(A,F,m,n)</span><br><span class="line">%选择算子。按个体适应度F从种群A中选取m个形成种群B，n为基因编码长度</span><br><span class="line">[p,~] = size(A);</span><br><span class="line">B = zeros(m,n);</span><br><span class="line">s = sum(F); % 默认对每列进行求和</span><br><span class="line">F = cumsum(F)/s; %cumsum()函数计算元素累加值，默认对每列进行累加</span><br><span class="line">rr = rand(1,m); %</span><br><span class="line"><span class="keyword">for</span> k=1:m</span><br><span class="line">    <span class="keyword">if</span> rr(k)&lt;F(1)</span><br><span class="line">        w = 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        con = 1;</span><br><span class="line">        t = 2;</span><br><span class="line">        <span class="keyword">while</span> t &lt;= p &amp;&amp; con == 1 %&amp;&amp;与</span><br><span class="line">            <span class="keyword">if</span> rr(k)&lt;F(t) &amp;&amp; rr(k)&gt;=F(t-1)</span><br><span class="line">                w = t;</span><br><span class="line">                con = 0;</span><br><span class="line">            end</span><br><span class="line">            t = t+1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    B(k,:) = A(w,:);</span><br><span class="line">    %D(k) = w;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>交叉算子，单点交叉操作。</p>
</blockquote>
<p><strong>k</strong>表示选择位，<strong>n</strong>表示总位数，<strong>r</strong>表示交叉概率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> B = fun_crossover(A,k,n,r)</span><br><span class="line">%交叉算子，单点交叉操作。k表示选择位，n表示总位数，r表示交叉概率</span><br><span class="line">[p,q] = size(A);</span><br><span class="line">B = zeros(p,q);</span><br><span class="line">R = rand(p,1);</span><br><span class="line"><span class="keyword">for</span> i = 1:2:p</span><br><span class="line">    <span class="keyword">if</span> R(i)&lt;r</span><br><span class="line">        a = A(i,:);</span><br><span class="line">        b = A(i+1,:);</span><br><span class="line">        a1 = a(1:k-1);</span><br><span class="line">        a2 = a(k:n);</span><br><span class="line">        b1 = b(1:k-1);</span><br><span class="line">        b2 = b(k:n);</span><br><span class="line">        B(i,:) = [a1,b2];</span><br><span class="line">        B(i+1,:) = [b1,a2];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B(i,:) = A(i,:);</span><br><span class="line">        B(i+1,:) = A(i+1,:);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>变异算子</p>
</blockquote>
<p>以变异概率<strong>r</strong>对种群A中基因进行变异操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> A = fun_mutation(A,r)</span><br><span class="line">%变异算子，以变异概率r对种群A中基因进行变异操作</span><br><span class="line">[p,q] = size(A);</span><br><span class="line">B = rand(p,q);</span><br><span class="line"><span class="keyword">for</span> i = 1:p</span><br><span class="line">    <span class="keyword">for</span> j = 1:q</span><br><span class="line">        <span class="keyword">if</span> B(i,j)&lt;r</span><br><span class="line">            <span class="keyword">if</span> A(i,j) == 1</span><br><span class="line">                A(i,j)=0;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A(i,j) = 1;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>函数值计算</p>
</blockquote>
<p><strong>n</strong>为染色体长度，<strong>[a，b]</strong>为变量取值范围，<strong>xx</strong>为染色体解码，<strong>yy</strong>为目标函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [xx,yy] = fun_value(A,n,a,b)</span><br><span class="line">%函数值计算</span><br><span class="line">%n为染色体长度，[a，b]为变量取值范围，xx为染色体解码，yy为目标函数</span><br><span class="line">[p,q] = size(A);</span><br><span class="line">xx = fun_decode(A,n,a,b);</span><br><span class="line">yy = zeros(p,1);</span><br><span class="line"><span class="keyword">for</span> i=1:p</span><br><span class="line">    x = xx(i);</span><br><span class="line">    yy(i,1) = 8*sin(5*x)+5*cos(4*x);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>解码操作</p>
</blockquote>
<p>将二进制基因编码转换为在<strong>[a,b]</strong>内对应的十进制数值,<strong>n</strong>为染色体长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> d = fun_decode(A,n,a,b)</span><br><span class="line">% 解码操作，将二进制基因编码转换为在[a,b]内对应的十进制数值,n为染色体长度</span><br><span class="line">[p,~] = size(A); %p为矩阵行数，q为矩阵列数</span><br><span class="line">d = zeros(p,1);</span><br><span class="line"><span class="keyword">for</span> k = 1:p</span><br><span class="line">    x = A(k,:);</span><br><span class="line">    ss = 0;</span><br><span class="line">    <span class="keyword">for</span> i = 1:n</span><br><span class="line">        ss = ss + x(i)*2^(n-i);</span><br><span class="line">    end</span><br><span class="line">    d(k,1) = a + ss*(b<span class="_">-a</span>)/(2^n-1);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Matlab 算法实现</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔密码(Hill Cipher)的Python实现</title>
    <url>/2020/12/11/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81(Hill%20Cipher)%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>此程序为希尔密码(Hill Cipher)的Python实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 《信息论基础》、百度百科-希尔密码 (https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81/2250150?fr=aladdin)</span></span><br><span class="line"><span class="string">Completion time：2020-11-27</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">import math</span><br><span class="line">import numpy as np</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#加/解密算法</span></span><br><span class="line">def <span class="keyword">function</span>(matrix):</span><br><span class="line">    List = []</span><br><span class="line">    STR = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> i[j]:</span><br><span class="line">                List.append(letter_dict[h])</span><br><span class="line">            <span class="keyword">if</span> len(i)- j &gt; 1:</span><br><span class="line">                List.append(letter_dict[<span class="string">' '</span>])</span><br><span class="line">        <span class="keyword">while</span>(not len(List)%4 == 0):</span><br><span class="line">            List.append(letter_dict[<span class="string">' '</span>])</span><br><span class="line">        B = np.array(List).reshape(-1,4)</span><br><span class="line">        C = np.dot(matrix,np.transpose(B))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> np.transpose(C).reshape(1,-1)[0]:</span><br><span class="line">            STR = STR + num_dict[(round(k))%53]         <span class="comment">#round()确保矩阵计算精度</span></span><br><span class="line">        <span class="built_in">print</span>(STR)</span><br><span class="line">        List = []     </span><br><span class="line">        STR = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 《信息论基础》、百度百科-希尔密码 (https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81/2250150?fr=aladdin)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-27"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-28"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;希尔密码(MOD53)&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"该程序目前只接受大小写英文加密讯息(支持空格)!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"若要结束输入，请按两次回车"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"每次运行程序，密钥都会改变!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"为保证解码顺利，密钥矩阵|A|=+/-1!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"********************博客网址********************"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"欢迎访问：https://hong-king.github.io/"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"************************************************"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---------------------------------------------------------------"</span>,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建码符集</span></span><br><span class="line">letter = [<span class="string">' '</span>]+[chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(97, 123)] + [chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(65, 91)]</span><br><span class="line">letter_dict = dict(zip(letter,range(len(letter))))</span><br><span class="line">num_dict = dict(zip(range(len(letter)),letter))</span><br><span class="line">                   </span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"请输入需要加密的英文讯息:"</span>)</span><br><span class="line">message = []</span><br><span class="line">try:</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        m = sys.stdin.readline().strip() <span class="comment">#若是多输入，strip()默认是以空格分隔，返回一个包含多个字符串的list。</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">''</span>:</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        m = list(m.split())</span><br><span class="line">        message.append(m)</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"正在加密，请稍后...."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成随机4阶可逆矩阵(密钥)</span></span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">为减小运算压力，设随机矩阵大小为4*4，随机整数元素区间为[1,10]</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">A = np.random.randint(1, 10, size=(4,4)) <span class="comment">#生成[1,10]区间的整数随机矩阵(密钥)</span></span><br><span class="line"><span class="keyword">while</span> (not abs(np.linalg.det(A)) == 1 ): <span class="comment">#该条件用于保证密钥的逆矩阵为整数</span></span><br><span class="line">    A = np.random.randint(1, 10, size=(4,4))</span><br><span class="line">A_Inv = np.linalg.inv(A)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------密钥-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------密文-------------------"</span>)</span><br><span class="line"><span class="keyword">function</span>(A)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"****************解码****************"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"请输入密文："</span>)</span><br><span class="line">message = []</span><br><span class="line">try:</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        m = sys.stdin.readline().strip() <span class="comment">#若是多输入，strip()默认是以空格分隔，返回一个包含多个字符串的list。</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">''</span>:</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        m = list(m.split())</span><br><span class="line">        message.append(m)</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"正在解密，请稍后...."</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------原文-------------------"</span>)</span><br><span class="line"><span class="keyword">function</span>(A_Inv)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 从输入端读取多行数据</title>
    <url>/2020/11/27/Python%20%E4%BB%8E%E8%BE%93%E5%85%A5%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%A4%9A%E8%A1%8C%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>该方法解决Python从输入端一次读取多个数据的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    mx = []</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        m = sys.stdin.readline().strip()</span><br><span class="line">        <span class="comment">#若是多输入，strip()默认是以空格分隔，返回一个包含多个字符串的list。</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">''</span>:</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        m = list(m.split())</span><br><span class="line">        mx.append(m)</span><br><span class="line">    <span class="built_in">print</span>(mx)</span><br><span class="line">except:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用reshape重塑数组</title>
    <url>/2020/11/27/%E5%88%A9%E7%94%A8reshape%E9%87%8D%E5%A1%91numpy%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>在数据预处理阶段，我们经常需要重塑数组。这里所介绍的numpy内置属性reshape将有助于此</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">z = np.array([[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],[13, 14, 15, 16]])</span><br><span class="line"><span class="comment"># 创建一个形状为（4，4）的数组[z]</span></span><br><span class="line">a = z.reshape(-1)</span><br><span class="line"><span class="comment">#reshape(1,-1)转化成1行：</span></span><br><span class="line"><span class="comment">#reshape(2,-1)转换成两行：</span></span><br><span class="line"><span class="comment">#reshape(-1,1)转换成1列：</span></span><br><span class="line"><span class="comment">#reshape(-1,2)转化成两列</span></span><br><span class="line"><span class="comment"># 使用reshape重塑数组[z]</span></span><br><span class="line">[out]:</span><br><span class="line">	[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 ]</span><br><span class="line"><span class="comment">#----------------------------------------------------------</span></span><br><span class="line">a = z.reshape(-1,2)</span><br><span class="line"><span class="comment"># 在这种用法中，-1可以理解为数组行数待定，2表示重组后的数组列数为2</span></span><br><span class="line">[out]:</span><br><span class="line">	[[ 1  2]</span><br><span class="line">	 [ 3  4]</span><br><span class="line">	 [ 5  6]</span><br><span class="line">	 [ 7  8]</span><br><span class="line">	 [ 9 10]</span><br><span class="line">	 [11 12]</span><br><span class="line">	 [13 14]</span><br><span class="line">	 [15 16]]</span><br><span class="line"><span class="comment">#--------------------------------------------------------------</span></span><br><span class="line">a = z.reshape(2,2,4)</span><br><span class="line"><span class="comment"># 也可以指定行列，但重组后的矩阵元素数量必须与之前相同</span></span><br><span class="line">[out]:</span><br><span class="line">	[[[ 1  2  3  4]</span><br><span class="line">	  [ 5  6  7  8]]</span><br><span class="line"></span><br><span class="line">	 [[ 9 10 11 12]</span><br><span class="line">	  [13 14 15 16]]]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在TensorFlow中还可以利用tf.reshape对数组重塑</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf.reshape(tensor,shape,name=None)</span><br><span class="line"><span class="comment"># tensor表示要处理的对象，shape表示目标矩阵形状（如[num，num]）</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼(Huffman)编码的Python实现</title>
    <url>/2020/11/25/%E5%93%88%E5%A4%AB%E6%9B%BC(Huffman)%E7%BC%96%E7%A0%81%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>此程序为哈夫曼(Huffman)编码的Python实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 《信息论基础》</span></span><br><span class="line"><span class="string">Completion time：2020-11-24</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;哈夫曼编码&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 《信息论基础》、百度百科-哈夫曼编码 (https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-24"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-25"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------------------------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line">N_num = <span class="built_in">float</span>(input(<span class="string">"请输入需要编码字符个数："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_num &lt;= 0 or (N_num % 1)):</span><br><span class="line">    N_num = <span class="built_in">float</span>(input(<span class="string">"请输入正整数："</span>))</span><br><span class="line">N_num = int(N_num)</span><br><span class="line"></span><br><span class="line">Dict = []</span><br><span class="line">Huffman_dict = &#123;&#125;</span><br><span class="line">probability = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(N_num &gt; 0):</span><br><span class="line">    N_num = N_num-1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"------还需输入"</span>,N_num,<span class="string">"编码字符信息------"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"请输入一个编码字符名："</span>)</span><br><span class="line">    name = str(input())</span><br><span class="line">    Huffman_dict.setdefault(name)</span><br><span class="line">    Huffman_dict[name] = <span class="string">''</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请输入小于"</span>,probability,<span class="string">"的对应编码字符概率："</span>)</span><br><span class="line">    value = <span class="built_in">float</span>(input())</span><br><span class="line">    probability = probability - value</span><br><span class="line">    Dict.append((value,[name]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#按概率排序</span></span><br><span class="line">Dict_order=sorted(Dict,reverse=False)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编码算法</span></span><br><span class="line">Dict_order_copy = Dict_order</span><br><span class="line">Dict_order_copy_copy = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len(Dict_order_copy)&gt;1):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(Dict_order_copy)/2)):</span><br><span class="line">        <span class="keyword">if</span> len(Dict_order_copy)-2*(i+1) == 1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> Dict_order_copy[2*i][1]:</span><br><span class="line">                </span><br><span class="line">                   Huffman_dict[j] =  <span class="string">'0'</span> + Huffman_dict[j]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> Dict_order_copy[2*i+1][1]:</span><br><span class="line">                   Huffman_dict[j] =  <span class="string">'1'</span> + Huffman_dict[j]</span><br><span class="line">               </span><br><span class="line">            Dict_order_copy_copy.append((Dict_order_copy[2*i][0]+Dict_order_copy[2*i+1][0],Dict_order_copy[2*i][1]+Dict_order_copy[2*i+1][1]))</span><br><span class="line">            Dict_order_copy_copy.append((Dict_order_copy[len(Dict_order_copy)-1][0],Dict_order_copy[len(Dict_order_copy)-1][1]))</span><br><span class="line">        <span class="keyword">else</span>:    </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> Dict_order_copy[2*i][1]:</span><br><span class="line">                   Huffman_dict[j] = <span class="string">'0'</span> + Huffman_dict[j]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> Dict_order_copy[2*i+1][1]:</span><br><span class="line">                   Huffman_dict[j] = <span class="string">'1'</span> + Huffman_dict[j]</span><br><span class="line">                   </span><br><span class="line">            Dict_order_copy_copy.append((Dict_order_copy[2*i][0]+Dict_order_copy[2*i+1][0],Dict_order_copy[2*i][1]+Dict_order_copy[2*i+1][1]))</span><br><span class="line">            </span><br><span class="line">    Dict_order_copy = sorted(Dict_order_copy_copy,reverse=False)</span><br><span class="line"></span><br><span class="line">    Dict_order_copy_copy = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="built_in">print</span>(Huffman_dict)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>费诺(Fano)编码的Python实现</title>
    <url>/2020/11/25/%E8%B4%B9%E8%AF%BA(Fano)%E7%BC%96%E7%A0%81%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>此程序为费诺编码的Python实现,但此版本存在缺陷：每个编码符号出现的概率不能相同。该问题在第二个程序得到改进。</p>
<blockquote>
<p>第一个程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 《信息论基础》</span></span><br><span class="line"><span class="string">Completion time：2020-11-24</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="comment">#import pandas</span></span><br><span class="line"><span class="comment">#import time</span></span><br><span class="line">import math</span><br><span class="line"><span class="comment">#import sys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;费诺编码&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 《信息论基础》、百度百科-费诺编码 (https://baike.baidu.com/item/%E8%B4%B9%E8%AF%BA%E7%BC%96%E7%A0%81)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-24"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-24"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------------------------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line">N_num = <span class="built_in">float</span>(input(<span class="string">"请输入需要编码字符个数："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_num &lt;= 0 or (N_num % 1)):</span><br><span class="line">    N_num = <span class="built_in">float</span>(input(<span class="string">"请输入正整数："</span>))</span><br><span class="line">N_num = int(N_num)</span><br><span class="line"></span><br><span class="line">Dict = &#123;&#125;</span><br><span class="line">probability = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(N_num &gt; 0):</span><br><span class="line">    N_num = N_num-1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"------还需输入"</span>,N_num,<span class="string">"编码字符信息------"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"请输入一个编码字符名："</span>)</span><br><span class="line">    name = str(input())</span><br><span class="line">    Dict.setdefault(name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请输入小于"</span>,probability,<span class="string">"的对应编码字符概率："</span>)</span><br><span class="line">    value = <span class="built_in">float</span>(input())</span><br><span class="line">    probability = probability - value</span><br><span class="line">    Dict[name] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(Dict)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按概率排序</span></span><br><span class="line">Dict_order=sorted(Dict.items(),key=lambda x:x[1],reverse=True)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(Dict_order)</span></span><br><span class="line"><span class="comment">#sys.exit(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编码算法</span></span><br><span class="line">name = []</span><br><span class="line">value = []</span><br><span class="line"><span class="comment">#code = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#truncation = 0 #保存截断位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Dict_order:</span><br><span class="line">    name.append(i[0])</span><br><span class="line">    value.append(i[1])</span><br><span class="line">    </span><br><span class="line">Fano_dict_value = &#123;&#125;.fromkeys(value,<span class="string">''</span>)</span><br><span class="line"><span class="comment">#print(name)</span></span><br><span class="line"><span class="comment">#print(value)</span></span><br><span class="line"></span><br><span class="line">value_copy = [value]</span><br><span class="line">value_copy_copy = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(len(value_copy)&gt;0):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> value_copy:</span><br><span class="line">        <span class="keyword">if</span> len(k) == 2:</span><br><span class="line">            Fano_dict_value[k[0]] = Fano_dict_value[k[0]] + <span class="string">'0'</span></span><br><span class="line">            Fano_dict_value[k[1]] = Fano_dict_value[k[1]] + <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(k)):</span><br><span class="line">                a = sum(k[:i])</span><br><span class="line">                b = sum(k[i:])</span><br><span class="line">                c = sum(k[:(i+1)])</span><br><span class="line">                d = sum(k[(i+1):])</span><br><span class="line">                <span class="keyword">if</span> abs(a-b)&lt;abs(c<span class="_">-d</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == 1:</span><br><span class="line">                        Fano_dict_value[k[0]] = Fano_dict_value[k[0]] + <span class="string">'0'</span></span><br><span class="line">                        value_copy_copy.append(k[1:])</span><br><span class="line">                        <span class="keyword">for</span> h <span class="keyword">in</span> k[1:]:</span><br><span class="line">                            Fano_dict_value[h] = Fano_dict_value[h] + <span class="string">'1'</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        value_copy_copy.append(k[:i])</span><br><span class="line">                        value_copy_copy.append(k[i:])</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> k[:i]:</span><br><span class="line">                            Fano_dict_value[j] = Fano_dict_value[j] + <span class="string">'0'</span></span><br><span class="line">                        <span class="keyword">for</span> h <span class="keyword">in</span> k[i:]:</span><br><span class="line">                            Fano_dict_value[h] = Fano_dict_value[h] + <span class="string">'1'</span></span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line">    value_copy = value_copy_copy</span><br><span class="line">    value_copy_copy = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">Fano_dict = dict(zip(name,Fano_dict_value.values()))</span><br><span class="line"><span class="built_in">print</span>(Fano_dict)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<blockquote>
<p>第二个程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 《信息论基础》</span></span><br><span class="line"><span class="string">Completion time：2020-11-24</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;费诺编码&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 《信息论基础》、百度百科-费诺编码 (https://baike.baidu.com/item/%E8%B4%B9%E8%AF%BA%E7%BC%96%E7%A0%81)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-24"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-25"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------------------------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line">N_num = <span class="built_in">float</span>(input(<span class="string">"请输入需要编码字符个数："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_num &lt;= 0 or (N_num % 1)):</span><br><span class="line">    N_num = <span class="built_in">float</span>(input(<span class="string">"请输入正整数："</span>))</span><br><span class="line">N_num = int(N_num)</span><br><span class="line"></span><br><span class="line">Dict = &#123;&#125;</span><br><span class="line">probability = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(N_num &gt; 0):</span><br><span class="line">    N_num = N_num-1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"------还需输入"</span>,N_num,<span class="string">"编码字符信息------"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"请输入一个编码字符名："</span>)</span><br><span class="line">    name = str(input())</span><br><span class="line">    Dict.setdefault(name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请输入小于"</span>,probability,<span class="string">"的对应编码字符概率："</span>)</span><br><span class="line">    value = <span class="built_in">float</span>(input())</span><br><span class="line">    probability = probability - value</span><br><span class="line">    Dict[name] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#按概率排序</span></span><br><span class="line">Dict_order=sorted(Dict.items(),key=lambda x:x[1],reverse=True)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编码算法</span></span><br><span class="line">name = []</span><br><span class="line">value = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Dict_order:</span><br><span class="line">    name.append(i[0])</span><br><span class="line">    value.append(i[1])</span><br><span class="line">    </span><br><span class="line">Fano_dict = &#123;&#125;.fromkeys(name,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">value_copy = [value]</span><br><span class="line">value_copy_copy = []</span><br><span class="line">name_copy = [name]</span><br><span class="line">name_copy_copy = []</span><br><span class="line"><span class="keyword">while</span>(len(value_copy)&gt;0):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(value_copy)):</span><br><span class="line">        <span class="keyword">if</span> len(value_copy[k]) == 2:</span><br><span class="line">            Fano_dict[name_copy[k][0]] = Fano_dict[name_copy[k][0]] + <span class="string">'0'</span></span><br><span class="line">            Fano_dict[name_copy[k][1]] = Fano_dict[name_copy[k][1]] + <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_copy[k])):</span><br><span class="line">                a = sum(value_copy[k][:i])</span><br><span class="line">                b = sum(value_copy[k][i:])</span><br><span class="line">                c = sum(value_copy[k][:(i+1)])</span><br><span class="line">                d = sum(value_copy[k][(i+1):])</span><br><span class="line">                <span class="keyword">if</span> abs(a-b)&lt;abs(c<span class="_">-d</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == 1:</span><br><span class="line">                        Fano_dict[name_copy[k][0]] = Fano_dict[name_copy[k][0]] + <span class="string">'0'</span></span><br><span class="line">                        value_copy_copy.append(value_copy[k][1:])</span><br><span class="line">                        name_copy_copy.append(name_copy[k][1:])</span><br><span class="line">                        <span class="keyword">for</span> h <span class="keyword">in</span> name_copy[k][1:]:</span><br><span class="line">                            Fano_dict[h] = Fano_dict[h] + <span class="string">'1'</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        value_copy_copy.append(value_copy[k][:i])</span><br><span class="line">                        value_copy_copy.append(value_copy[k][i:])</span><br><span class="line">                        name_copy_copy.append(name_copy[k][:i])</span><br><span class="line">                        name_copy_copy.append(name_copy[k][i:])</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> name_copy[k][:i]:</span><br><span class="line">                            Fano_dict[j] = Fano_dict[j] + <span class="string">'0'</span></span><br><span class="line">                        <span class="keyword">for</span> h <span class="keyword">in</span> name_copy[k][i:]:</span><br><span class="line">                            Fano_dict[h] = Fano_dict[h] + <span class="string">'1'</span></span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line">    value_copy = value_copy_copy</span><br><span class="line">    name_copy = name_copy_copy</span><br><span class="line">    value_copy_copy = []</span><br><span class="line">    name_copy_copy = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="built_in">print</span>(Fano_dict)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>香农(Shannon)编码的Python实现</title>
    <url>/2020/11/24/%E9%A6%99%E5%86%9C(Shannon)%E7%BC%96%E7%A0%81%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>此程序为香农编码的Python实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 《信息论基础》</span></span><br><span class="line"><span class="string">Completion time：2020-11-23</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="comment">#import pandas</span></span><br><span class="line"><span class="comment">#import time</span></span><br><span class="line">import math</span><br><span class="line"><span class="comment">#import sys</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;香农编码&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 《信息论基础》、百度百科-香农编码 (https://baike.baidu.com/item/%E9%A6%99%E5%86%9C%E7%BC%96%E7%A0%81/22353186?fr=aladdin)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-23"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-23"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------------------------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line">N_num = <span class="built_in">float</span>(input(<span class="string">"请输入需要编码字符个数："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_num &lt;= 0 or (N_num % 1)):</span><br><span class="line">    N_num = <span class="built_in">float</span>(input(<span class="string">"请输入正整数："</span>))</span><br><span class="line">N_num = int(N_num)</span><br><span class="line"></span><br><span class="line">Dict = &#123;&#125;</span><br><span class="line">probability = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(N_num &gt; 0):</span><br><span class="line">    N_num = N_num-1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"------还需输入"</span>,N_num,<span class="string">"编码字符信息------"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"请输入一个编码字符名："</span>)</span><br><span class="line">    name = str(input())</span><br><span class="line">    Dict.setdefault(name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"请输入小于"</span>,probability,<span class="string">"的对应编码字符概率："</span>)</span><br><span class="line">    value = <span class="built_in">float</span>(input())</span><br><span class="line">    probability = probability - value</span><br><span class="line">    Dict[name] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(Dict)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#按概率排序</span></span><br><span class="line">Dict_order=sorted(Dict.items(),key=lambda x:x[1],reverse=True)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(Dict_order)</span></span><br><span class="line"><span class="comment">#sys.exit(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编码算法</span></span><br><span class="line">Q = 0  <span class="comment">#累加概率</span></span><br><span class="line">Shannon_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Dict_order:</span><br><span class="line">    P = i[1]    <span class="comment">#字符概率</span></span><br><span class="line">    L = math.ceil(-math.log(P,2)) <span class="comment">#码长</span></span><br><span class="line">    Autoregressive_variable = 0</span><br><span class="line">    num = Q</span><br><span class="line">    word = <span class="string">""</span>   <span class="comment">#码字</span></span><br><span class="line">    <span class="keyword">while</span>(Autoregressive_variable &lt; L):</span><br><span class="line">        <span class="keyword">if</span> int(num) &lt; int(2*num):</span><br><span class="line">            word = word + <span class="string">'1'</span></span><br><span class="line">            num = 2*num - int(2*num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word = word + <span class="string">'0'</span></span><br><span class="line">            num = 2*num</span><br><span class="line">        Autoregressive_variable = Autoregressive_variable+1</span><br><span class="line">    Shannon_dict.setdefault(i[0])</span><br><span class="line">    Shannon_dict[i[0]] = word</span><br><span class="line">    Q = Q + P</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Shannon_dict编码结果："</span>,Shannon_dict)</span><br><span class="line"><span class="comment">#sys.exit(0)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>天平秤球问题的Python实现</title>
    <url>/2020/11/18/%E5%A4%A9%E5%B9%B3%E7%A7%A4%E7%90%83%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>此程序为信息论中提到的秤球问题的代码实现，但此算法功能并不完善。目前，该程序只能针对特定的情况给出特定的称量方法，无法给出通解。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">All rights reserved by Liu Junhong</span></span><br><span class="line"><span class="string">Reference books: 百度百科-称球问题 (https://baike.baidu.com/item/称球问题/16038399?fr=aladdin)</span></span><br><span class="line"><span class="string">Completion time：2020-11-16</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">import numpy as np</span><br><span class="line">import pandas</span><br><span class="line">import time</span><br><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(1000000) <span class="comment">#设置最大递归深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#程序说明</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------&lt;称球问题&gt;程序说明-------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Designed by 刘俊宏：All rights reserved"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Reference books: 百度百科-称球问题 (https://baike.baidu.com/item/称球问题/16038399?fr=aladdin)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completion time：2020-11-16"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Last modification time ：2020-11-24"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"程序缺陷：目前只能对于提供的特定称量情况，给出相对应的称量方案"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--------------------------------------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******录入数据</span></span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">N_num 所需判断球的总数(正整数)</span></span><br><span class="line"><span class="string">N_bad 坏球的序号(正整数)</span></span><br><span class="line"><span class="string">N_bad_weight 坏球的轻重(正整数)</span></span><br><span class="line"><span class="string">Weighing_times 所需称量的次数</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">N_num = <span class="built_in">float</span>(input(<span class="string">"请输入所需判断球的总数(正整数，n&gt;1)："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_num &lt;= 1 or (N_num % 1)):</span><br><span class="line">    N_num = <span class="built_in">float</span>(input(<span class="string">"请输入规范正整数："</span>))</span><br><span class="line">N_num = int(N_num)</span><br><span class="line">N = np.zeros(N_num,dtype=int)</span><br><span class="line"></span><br><span class="line">N_bad = <span class="built_in">float</span>(input(<span class="string">"请输入第几个球为坏球(正整数)："</span>))</span><br><span class="line"><span class="keyword">while</span>(N_bad &lt;= 0 or (N_bad % 1)):</span><br><span class="line">    N_bad = <span class="built_in">float</span>(input(<span class="string">"请输入正整数："</span>))</span><br><span class="line">N_bad = int(N_bad)</span><br><span class="line"></span><br><span class="line">N_bad_weight = <span class="built_in">float</span>(input(<span class="string">"请输入坏球的轻重(轻输入 -1，重输入 1)："</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((N_bad_weight != -1) and  (N_bad_weight != 1)):</span><br><span class="line">    </span><br><span class="line">    N_bad_weight = <span class="built_in">float</span>(input(<span class="string">"请输入正确数字："</span>))</span><br><span class="line">N_bad_weight = int(N_bad_weight)</span><br><span class="line"></span><br><span class="line">N[N_bad - 1] = N_bad_weight</span><br><span class="line"></span><br><span class="line">Weighing_times = math.ceil(math.log((2*N_num+3),3))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---------数据录入成功！---------"</span>,<span class="string">"\n"</span>)</span><br><span class="line">time.sleep(0.6)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"球的总数为："</span>,int(N_num),<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"第"</span>,int(N_bad),<span class="string">"个球为坏球"</span>,<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"球的数据概览如下："</span>,N,<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所需称量的次数为："</span>,Weighing_times,<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******算法部分</span></span><br><span class="line">def Random_generation():</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#生成符合条件的随机矩阵</span></span><br><span class="line">    A = np.random.randint(-1, 2, size=(Weighing_times,N_num)) <span class="comment">#生成[-1,2)区间的整数随机矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (not all(np.sum(A,axis=1) == 0)):</span><br><span class="line">        A = np.random.randint(-1, 2, size=(Weighing_times,N_num))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#进行矩阵乘法    </span></span><br><span class="line">    Y = np.dot(A,N.reshape((-1,1)))</span><br><span class="line">    <span class="keyword">if</span> all(Y == 0):         <span class="comment">#防止天平全平衡情况</span></span><br><span class="line">        Random_generation()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N_num):</span><br><span class="line">        LIST = list(range(N_num))</span><br><span class="line">        LIST.pop(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> all(Y == A[:,i].reshape((-1,1))) and (not any(all(Y == -A[:,j].reshape((-1,1))) <span class="keyword">for</span> j <span class="keyword">in</span> LIST)) and (not any(all(Y == A[:,j].reshape((-1,1))) <span class="keyword">for</span> j <span class="keyword">in</span> LIST)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"---------程序运行成功，输出结果：---------"</span>,<span class="string">"\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"第"</span>,i+1,<span class="string">"个球为坏的重球"</span>,<span class="string">"\n"</span>)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">elif</span> all(Y == -A[:,i].reshape((-1,1))) and (not any(all(Y == A[:,j].reshape((-1,1))) <span class="keyword">for</span> j <span class="keyword">in</span> LIST)) and (not any(all(Y == -A[:,j].reshape((-1,1))) <span class="keyword">for</span> j <span class="keyword">in</span> LIST)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"---------程序运行成功，输出结果：---------"</span>,<span class="string">"\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"第"</span>,i+1,<span class="string">"个球为坏的轻球"</span>,<span class="string">"\n"</span>)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">elif</span> i == N_num-1:</span><br><span class="line">            Random_generation()</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">return</span> A,Y</span><br><span class="line"></span><br><span class="line">A,Y = Random_generation()</span><br><span class="line"></span><br><span class="line"><span class="comment">#*******描述部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---------称量方法展示！---------"</span>,<span class="string">"\n"</span>)</span><br><span class="line">time.sleep(0.6)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(Weighing_times):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>,<span class="string">"第"</span>,i+1,<span class="string">"次称量:"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"左盘球的序号(从1开始计数):"</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N_num):</span><br><span class="line">        <span class="keyword">if</span> A[i,j] == 1:</span><br><span class="line">            <span class="built_in">print</span>(j+1)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"右盘球的序号(从1开始计数):"</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N_num):</span><br><span class="line">        <span class="keyword">if</span> A[i,j] == -1:</span><br><span class="line">            <span class="built_in">print</span>(j+1)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"称量结果:"</span>)</span><br><span class="line">    <span class="keyword">if</span> Y[i] == 1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"左盘重"</span>)</span><br><span class="line">    <span class="keyword">elif</span> Y[i] == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"平衡"</span>)</span><br><span class="line">    <span class="keyword">elif</span> Y[i] == -1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"右盘重"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python从文本中提取单词</title>
    <url>/2020/10/16/%E5%88%A9%E7%94%A8Python%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E6%8F%90%E5%8F%96%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>首先介绍string包的一些实用内置函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.digits  			<span class="comment">#所有的数字</span></span><br><span class="line"><span class="string">'0123456789'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.ascii_lowercase  <span class="comment">#所有的小写字母</span></span><br><span class="line"><span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.ascii_uppercase  <span class="comment">#所有的大写字母</span></span><br><span class="line"><span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.hexdigits        <span class="comment">#所有的十六进制字符</span></span><br><span class="line"><span class="string">'0123456789abcdefABCDEF'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.whitespace       <span class="comment">#所有的空白字符</span></span><br><span class="line"><span class="string">' \t\n\r\x0b\x0c'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; string.punctuation      <span class="comment">#所有的标点字符</span></span><br><span class="line"><span class="string">'!"#$%&amp;\'</span>()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~<span class="string">'</span></span><br></pre></td></tr></table></figure>
<p>接下来时python的一些内置函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy</span><br><span class="line">import pandas</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">data = open(<span class="string">"data.txt"</span>,<span class="string">"r"</span>,encoding = <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">##------------提取单词</span></span><br><span class="line">data.readlines()   		<span class="comment">#data.readlines()用于读取所有行，每行为一个元素</span></span><br><span class="line"></span><br><span class="line">data.replace(i,<span class="string">" "</span>) 	<span class="comment">#data.replace()用其他字符替换文本中的指定字符</span></span><br><span class="line"></span><br><span class="line">data.strip()        	<span class="comment">#data.strip用于移除字符串头尾指定的字符序列</span></span><br><span class="line"></span><br><span class="line">data.rstrip() 			<span class="comment">#rstrip() 删除字符串末尾的指定字符（默认为空格）</span></span><br><span class="line"></span><br><span class="line">data.split():           <span class="comment">#split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</span></span><br><span class="line"></span><br><span class="line">str.upper()          	<span class="comment"># 把所有字符中的小写字母转换成大写字母</span></span><br><span class="line"></span><br><span class="line">str.lower()         	<span class="comment"># 把所有字符中的大写字母转换成小写字母</span></span><br><span class="line"></span><br><span class="line">str.capitalize()   		<span class="comment"># 把第一个字母转化为大写字母，其余小写</span></span><br><span class="line"></span><br><span class="line">str.title()         	<span class="comment"># 把每个单词的第一个字母转化为大写，其余小写</span></span><br></pre></td></tr></table></figure>
<p>一下为解决一个英文文档单词提取问题的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import numpy</span><br><span class="line">import pandas</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">data = open(<span class="string">"data.txt"</span>,<span class="string">"r"</span>,encoding = <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">##------------提取单词</span></span><br><span class="line">words = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data.readlines():                                       <span class="comment">#.readlines用于读取所有行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> (string.punctuation.replace(<span class="string">"'"</span>,<span class="string">" "</span>)):  <span class="comment">#如果字符是标点符号的话就将其替换为空格,.replace("'"," ")用于剔除"'"符号</span></span><br><span class="line">            line = line.replace(i,<span class="string">" "</span>)</span><br><span class="line">    line = line.strip(<span class="string">'\n'</span>)                                         <span class="comment">#.strip用于移除字符串头尾指定的字符序列</span></span><br><span class="line">    line = line.strip(string.digits)                                <span class="comment">#string.digits方法的作用是生成数组，包括0-9</span></span><br><span class="line"><span class="comment">#    line = line.strip(string.punctuation)                           #string.punctuation所有的标点字符</span></span><br><span class="line"><span class="comment">#    line = line.rstrip(string.punctuation)                          #rstrip() 删除字符串末尾的指定字符（默认为空格）</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> line.split():                                       <span class="comment">#split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</span></span><br><span class="line">        words.add(word)</span><br><span class="line"><span class="built_in">print</span>(words)</span><br><span class="line">data.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>解决C++从输入流读取所需个数的数据后，多余数据仍存在输入流中的问题</title>
    <url>/2020/10/13/%E8%A7%A3%E5%86%B3C++%E4%BB%8E%E8%BE%93%E5%85%A5%E6%B5%81%E8%AF%BB%E5%8F%96%E6%89%80%E9%9C%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E5%A4%9A%E4%BD%99%E6%95%B0%E6%8D%AE%E4%BB%8D%E5%AD%98%E5%9C%A8%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在我用链表实现票务管理系统过程中，发现在输入超过所需个数的数据，并在下一次从输入流中读取数据时，上一次输入到输入流中未读取的数据仍在数据流中，故使程序错误运行，现将解决办法展示如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"--------【录入票务信息】----------\n"</span>);</span><br><span class="line">		fflush(stdin);//清空缓冲区</span><br><span class="line">		cout &lt;&lt; <span class="string">"请输入：起始站名 终点站名 火车编号 车票编号 票价"</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; Data.Terminus_Station &gt;&gt; Data.Departure_Station &gt;&gt; Data.Train_number &gt;&gt; Data.Ticketing_number &gt;&gt; Data.price;</span><br><span class="line">		cin.clear(); </span><br><span class="line">		cin.ignore(numeric_limits&lt;streamsize&gt;::max(), <span class="string">'\n'</span>); //清空输入流</span><br><span class="line">		insertNodeByHead(list_administrators, Data);</span><br><span class="line">		cout &lt;&lt; <span class="string">"信息录入成功!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>cin.clear()是用来更改cin的状态标示符的，cin在接收到错误的输入的时候，会设置状态位good。如果good位不为1，则cin不接受输入，直接跳过。如果下次输入前状态位没有改变那么即使清除了缓冲区数据流也无法输入。所以清除缓冲区之前必须要cin.clear()。</strong></p>
<p><strong>使用ignore清空输入流</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(),’\n’);	//清除输入缓冲区的当前行 </span><br><span class="line">cin.ignore(numeric_limits&lt;std::streamsize&gt;::max()); 		//清除输入缓冲区里所有内容 </span><br><span class="line">cin.ignore();												//清除一个字符</span><br><span class="line">cin.get(str,5).get();										//清除后面的换行符</span><br></pre></td></tr></table></figure>
<p>*numeric_limits<a href="std::streamsize">std::streamsize</a>::max()是climits头文件定义的流使用的最大值，你也可以用一个足够大的整数代替它。 </p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>C++ 基础语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>解决C++ ifstream 读取文件总多读一次问题</title>
    <url>/2020/10/12/%E8%A7%A3%E5%86%B3C++%20ifstream%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%80%BB%E5%A4%9A%E8%AF%BB%E4%B8%80%E6%AC%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//文件读操作</span><br><span class="line">void readInfoFromFile(struct LNode* headNode,const char* fileName)</span><br><span class="line">&#123;</span><br><span class="line">	struct Ticketing data;</span><br><span class="line">	ifstream fin(fileName);</span><br><span class="line">	<span class="keyword">while</span> (!fin.eof())</span><br><span class="line">	&#123;</span><br><span class="line">		fin &gt;&gt; data.Terminus_Station &gt;&gt; data.Departure_Station &gt;&gt; data.Train_number &gt;&gt; data.Ticketing_number &gt;&gt; data.price;</span><br><span class="line">	//	<span class="keyword">if</span> (fin.fail())</span><br><span class="line">	//		<span class="built_in">break</span>;</span><br><span class="line">		insertNodeByHead(headNode, data);</span><br><span class="line">	&#125;</span><br><span class="line">	fin.close();</span><br><span class="line">	fin.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果按上述原码操作，在读取文件数据时总是会多读取一遍。<br>查阅了<a href="https://www.cnblogs.com/youxin/p/3793814.html" target="_blank" rel="noopener">资料</a>后：<br>发现问题出在，fin对象在读取文件的时候，到末尾后后，再读一次才能判断到eof<br>因此最后一行会被读取两次。<br>解决方法是在while循环中加入判断：<br><strong>对于c风格的字符串可以使用:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[0]=<span class="string">'\0'</span>) //其中a是第一个被读入的对象</span><br><span class="line">	<span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>更加通用的形式:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in.fail())</span><br><span class="line">	<span class="built_in">break</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>C++ 基础语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络爬虫示例（有道词典）</title>
    <url>/2020/08/14/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%A4%BA%E4%BE%8B%EF%BC%88%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;sessionFrom='</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">'i'</span>] = <span class="string">'hellow world'</span></span><br><span class="line">data[<span class="string">'from'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">data[<span class="string">'to'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">data[<span class="string">'smartresult'</span>] = <span class="string">'fanyideskweb'</span></span><br><span class="line">data[<span class="string">'salt'</span>] = <span class="string">'15974087852539'</span></span><br><span class="line">data[<span class="string">'sign'</span>] = <span class="string">'bf425f71f33933c9acf4bfbf4e7977f2'</span></span><br><span class="line">data[<span class="string">'lts'</span>] = <span class="string">'1597408785253'</span></span><br><span class="line">data[<span class="string">'bv'</span>] = <span class="string">'4a974ec57c26e120374ce7e28f9434e5'</span></span><br><span class="line">data[<span class="string">'client'</span>] = <span class="string">'dict'</span></span><br><span class="line">data[<span class="string">'doctype'</span>] = <span class="string">'json'</span></span><br><span class="line">data[<span class="string">'version'</span>] = <span class="string">'2.1'</span></span><br><span class="line">data[<span class="string">'keyfrom'</span>] = <span class="string">'fanyi.web'</span></span><br><span class="line">data[<span class="string">'action'</span>] = <span class="string">'FY_BY_CLICKBUTTION'</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(url,data)</span><br><span class="line">html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 表格数据合并函数merge()</title>
    <url>/2020/08/09/python%20%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E5%87%BD%E6%95%B0merge()/</url>
    <content><![CDATA[<p>函数merge()的用法有点类似SQL语言</p>
<h3 id="左右连接键名一样"><a href="#左右连接键名一样" class="headerlink" title="左右连接键名一样"></a>左右连接键名一样</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df1=pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>],<span class="string">'value1'</span>:range(5)&#125;)</span><br><span class="line">df2=pd.DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>],<span class="string">'value2'</span>:range(5)&#125;)</span><br><span class="line">display(df1,df2,pd.merge(df1,df2))</span><br></pre></td></tr></table></figure>

<p>df1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    key  value1          </span><br><span class="line">0 	a		  0</span><br><span class="line">1	  b		  1</span><br><span class="line">2	  a		  2</span><br><span class="line">3	  b		  3</span><br><span class="line">4	  b		  4</span><br></pre></td></tr></table></figure>

<p>df2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    key  value2</span><br><span class="line">0	  a		  0</span><br><span class="line">1	  c		  1</span><br><span class="line">2	  c		  2</span><br><span class="line">3	  c		  3</span><br><span class="line">4	  c		  4</span><br></pre></td></tr></table></figure>

<p>pd.merge(df1,df2) ##以df1、df2中相同的列名key进行连接,默认how=’inner’, pd.merge(df1,df2,on=’key’,how=’inner’)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   key  value1 value2</span><br><span class="line">0	  a	    0	    0</span><br><span class="line">1	  a	    2	    0</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>pd.merge(df1,df2,how=’outer’) ##  全连接，取并集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	key	value1	value2</span><br><span class="line">0	  a	  0.0		0.0</span><br><span class="line">1 	a	  2.0		0.0</span><br><span class="line">2 	b	  1.0		NaN</span><br><span class="line">3	  b	  3.0		NaN</span><br><span class="line">4	  b	  4.0		NaN</span><br><span class="line">5 	c	  NaN		1.0</span><br><span class="line">6	  c	  NaN		2.0</span><br><span class="line">7	  c	  NaN		3.0</span><br><span class="line">8	  c	  NaN		4.0</span><br></pre></td></tr></table></figure>

<p>pd.merge(df1,df2,how=’left’)  ### 左连接，左边取全部，右边取部分，没有值则用NaN填充</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   key   value1   value2</span><br><span class="line">0	  a		   0		   0.0</span><br><span class="line">1	  b		   1		   NaN</span><br><span class="line">2	  a		   2		   0.0</span><br><span class="line">3	  b		   3		   NaN</span><br><span class="line">4	  b		   4		   NaN</span><br></pre></td></tr></table></figure>

<p>pd.merge(df1,df2,how=’right’) ###  右连接，右边取全部，左边取部分，没有值则用NaN填充</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	key   value1  value2</span><br><span class="line">0	a	  	 0.0		 0</span><br><span class="line">1	a		   2.0		 0</span><br><span class="line">2	c	  	 NaN		 1</span><br><span class="line">3	c		   NaN		 2</span><br><span class="line">4	c		   NaN		 3</span><br><span class="line">5	c		   NaN		 4</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="左右连接键名不一样"><a href="#左右连接键名不一样" class="headerlink" title="左右连接键名不一样"></a>左右连接键名不一样</h3><p>如果两个DataFrame的左右连接键的列名不一样，可以用left_on，right_on来进行指定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df3=pd.DataFrame(&#123;<span class="string">'lkey'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>],<span class="string">'data1'</span>:range(5)&#125;)</span><br><span class="line">df4=pd.DataFrame(&#123;<span class="string">'rkey'</span>:[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>],<span class="string">'data2'</span>:range(5)&#125;)</span><br></pre></td></tr></table></figure>

<p>df3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    lkey  data1</span><br><span class="line">0    a      0</span><br><span class="line">1    b      1</span><br><span class="line">2    a      2</span><br><span class="line">3    b      3</span><br><span class="line">4    b      4</span><br></pre></td></tr></table></figure>

<p>df4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    rkey  data2</span><br><span class="line">0    a      0</span><br><span class="line">1    c      1</span><br><span class="line">2    c      2</span><br><span class="line">3    c      3</span><br><span class="line">4    c      4</span><br></pre></td></tr></table></figure>

<p>pd.merge(df3,df4,left_on=’lkey’,right_on=’rkey’)   ### 内连接，默认how=’inner’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    lkey  data1 rkey  data2</span><br><span class="line">0    a      0    a      0</span><br><span class="line">1    a      2    a      0</span><br></pre></td></tr></table></figure>

<p>pd.merge(df3,df4,left_on=’lkey’,right_on=’lkey’,how=’outer’)  ### 全连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    lkey  data1 rkey  data2</span><br><span class="line">0    a    0.0    a    0.0</span><br><span class="line">1    a    2.0    a    0.0</span><br><span class="line">2    b    1.0  NaN    NaN</span><br><span class="line">3    b    3.0  NaN    NaN</span><br><span class="line">4    b    4.0  NaN    NaN</span><br><span class="line">5  NaN    NaN    c    1.0</span><br><span class="line">6  NaN    NaN    c    2.0</span><br><span class="line">7  NaN    NaN    c    3.0</span><br><span class="line">8  NaN    NaN    c    4.0</span><br></pre></td></tr></table></figure>

<p>pd.merge(df3,df4,left_on=’lkey’,right_on=’rkey’,how=’left’)  ### 左连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    lkey  data1 rkey  data2</span><br><span class="line">0    a      0    a    0.0</span><br><span class="line">1    b      1  NaN    NaN</span><br><span class="line">2    a      2    a    0.0</span><br><span class="line">3    b      3  NaN    NaN</span><br><span class="line">4    b      4  NaN    NaN</span><br></pre></td></tr></table></figure>

<p>pd.merge(df3,df4,left_on=’lkey’,right_on=’rkey’,how=’right’)  ### 右连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    lkey  data1 rkey  data2</span><br><span class="line">0    a    0.0    a      0</span><br><span class="line">1    a    2.0    a      0</span><br><span class="line">2  NaN    NaN    c      1</span><br><span class="line">3  NaN    NaN    c      2</span><br><span class="line">4  NaN    NaN    c      3</span><br><span class="line">5  NaN    NaN    c      4</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="索引作为连接键"><a href="#索引作为连接键" class="headerlink" title="索引作为连接键"></a>索引作为连接键</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df5=pd.DataFrame(np.arange(12).reshape(3,4),index=list(<span class="string">'abc'</span>),columns=[<span class="string">'v1'</span>,<span class="string">'v2'</span>,<span class="string">'v3'</span>,<span class="string">'v4'</span>])</span><br><span class="line">df6=pd.DataFrame(np.arange(12,24,1).reshape(3,4),index=list(<span class="string">'abd'</span>),columns=[<span class="string">'v5'</span>,<span class="string">'v6'</span>,<span class="string">'v7'</span>,<span class="string">'v8'</span>])</span><br></pre></td></tr></table></figure>

<p>df5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    v1  v2  v3  v4</span><br><span class="line">a   0   1   2   3</span><br><span class="line">b   4   5   6   7</span><br><span class="line">c   8   9  10  11</span><br></pre></td></tr></table></figure>

<p>df6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   v5  v6  v7  v8</span><br><span class="line">a  12  13  14  15</span><br><span class="line">b  16  17  18  19</span><br><span class="line">d  20  21  22  23</span><br></pre></td></tr></table></figure>

<p>pd.merge(df5,df6,left_index=True,right_index=True)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	v1	v2	v3	v4	v5	v6	v7	v8</span><br><span class="line">a	0	1	2	3	12	13	14	15</span><br><span class="line">b	4	5	6	7	16	17	18	19</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于在Python中利用pandas读取与保存csv文件失败的解决方法(&#39;utf-8&#39;编码格式不对)</title>
    <url>/2020/08/09/%E5%85%B3%E4%BA%8E%E5%9C%A8Python%E4%B8%AD%E5%88%A9%E7%94%A8pandas%E8%AF%BB%E5%8F%96csv%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95(&#39;utf-8&#39;%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E4%B8%8D%E5%AF%B9)/</url>
    <content><![CDATA[<p>在一开始我遇到了这个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(<span class="string">'data1.csv'</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">[out]:</span><br><span class="line">	UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xc4 in position 0: invalid continuation byte</span></span><br></pre></td></tr></table></figure>
<p>开始不知道如何解决，一直想通过下载csv包来解决，但pip里没有这个包。后来我通过对csv文件进行“只读”操作后，发出现程序可以运行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(open(<span class="string">'data1.csv'</span>,<span class="string">'r'</span>))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<hr>
<p>在保存时我也遇到了编码格式不对的错误，我是这样解决的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">data1 = pd.read_csv(open(<span class="string">'data1.csv'</span>,<span class="string">'r'</span>))</span><br><span class="line">data2 = pd.read_csv(open(<span class="string">'data2.csv'</span>,<span class="string">'r'</span>))</span><br><span class="line">data3 = pd.read_csv(open(<span class="string">'data3.csv'</span>,<span class="string">'r'</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data1))</span><br><span class="line">result = pd.merge(data1, data2 ,on=<span class="string">'CardNo'</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result.to_csv(<span class="string">'data4.csv'</span>,encoding=<span class="string">"utf_8_sig"</span>) <span class="comment">#用于解决编码错误问题</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言dgCMatrix稀疏矩阵结构</title>
    <url>/2020/08/06/R%E8%AF%AD%E8%A8%80dgCMatrix%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; str(mat)</span><br><span class="line">Formal class <span class="string">'dgCMatrix'</span> [package <span class="string">"Matrix"</span>] with 6 slots</span><br><span class="line">  ..@ i       : int(0) </span><br><span class="line">  ..@ p       : int [1:8190] 0 0 0 0 0 0 0 0 0 0 ...</span><br><span class="line">  ..@ Dim     : int [1:2] 320127 8189 <span class="comment">#记录矩阵的维度信息</span></span><br><span class="line">  ..@ Dimnames:List of 2 <span class="comment">#记录行名和列名</span></span><br><span class="line">  .. ..$ : NULL</span><br><span class="line">  .. ..$ : NULL</span><br><span class="line">  ..@ x       : num(0) <span class="comment">#记录不为0的数值</span></span><br><span class="line">  ..@ factors : list()</span><br></pre></td></tr></table></figure>
<p><strong>@Dim</strong>记录矩阵的维度信息, <strong>@Dimnames</strong>记录行名和列名, <strong>@x</strong>记录不为0的数值。<strong>@i</strong>记录不为0的行索引，由于这里全为0，所以不记录。<strong>@p</strong>(待定更新)</p>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>R语言 基础语法</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习笔记</title>
    <url>/2020/07/20/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h3 id="使用getwd-函数来显示当前工作目录"><a href="#使用getwd-函数来显示当前工作目录" class="headerlink" title="使用getwd()函数来显示当前工作目录"></a>使用<em>getwd()</em>函数来显示当前工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1] <span class="string">"C:/Users/lenovo/Documents"</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用setwd-函数来修改工作目录"><a href="#使用setwd-函数来修改工作目录" class="headerlink" title="使用setwd()函数来修改工作目录"></a>使用<em>setwd()</em>函数来修改工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setwd(dir = <span class="string">"目标工作路径"</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="在R中建议使用”-lt-“符号来进行赋值，符号”-lt-lt-“表示强制赋值给一个全局变量。"><a href="#在R中建议使用”-lt-“符号来进行赋值，符号”-lt-lt-“表示强制赋值给一个全局变量。" class="headerlink" title="在R中建议使用”&lt;-“符号来进行赋值，符号”&lt;&lt;-“表示强制赋值给一个全局变量。"></a>在R中建议使用”&lt;-“符号来进行赋值，符号”&lt;&lt;-“表示强制赋值给一个全局变量。</h3><hr>
<h3 id="使用ls-函数来查看当前工作空间中存在的已定义的变量和函数，使用str-变量名-会列出改变量的详细信息，使用ls-str-会列出所有已定义变量和函数详细的信息。"><a href="#使用ls-函数来查看当前工作空间中存在的已定义的变量和函数，使用str-变量名-会列出改变量的详细信息，使用ls-str-会列出所有已定义变量和函数详细的信息。" class="headerlink" title="使用ls()函数来查看当前工作空间中存在的已定义的变量和函数，使用str(变量名)会列出改变量的详细信息，使用ls.str()会列出所有已定义变量和函数详细的信息。"></a>使用<em>ls()</em>函数来查看当前工作空间中存在的已定义的变量和函数，使用<em>str(变量名)</em>会列出改变量的详细信息，使用<em>ls.str()</em>会列出所有已定义变量和函数详细的信息。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls()</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1] <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------</span></span><br><span class="line"></span><br><span class="line">str(x)</span><br><span class="line">str(y)</span><br><span class="line">str(z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	num 3</span><br><span class="line">	num 15</span><br><span class="line">	num 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------</span></span><br><span class="line"></span><br><span class="line">ls.str()</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	x : num 3</span><br><span class="line">	y : num 15</span><br><span class="line">	z : num 1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h1 id="向量索引"><a href="#向量索引" class="headerlink" title="向量索引"></a>向量索引</h1><h3 id="利用C-函数来构建向量，并赋值给x变量-c函数用于执行组合功能"><a href="#利用C-函数来构建向量，并赋值给x变量-c函数用于执行组合功能" class="headerlink" title="利用C()函数来构建向量，并赋值给x变量(c函数用于执行组合功能)"></a>利用<em>C()</em>函数来构建向量，并赋值给x变量(c函数用于执行组合功能)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x &lt;- c(1:10)</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1]  1  2  3  4  5  6  7  8  9 10</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="利用C-函数对数组-x-进行基础操作"><a href="#利用C-函数对数组-x-进行基础操作" class="headerlink" title="利用C()函数对数组(x)进行基础操作"></a>利用<em>C()</em>函数对数组(x)进行基础操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x[1] % x下标从1开始取</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1] 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------</span></span><br><span class="line"></span><br><span class="line">x[0] % 当要输出下标为0的数时，不会输出任何有效值</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	<span class="built_in">integer</span>(0) % 0不是正整数</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------</span></span><br><span class="line"></span><br><span class="line">x[-1] % 当使用负号索引时，表示输出除该索引的所有元素</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1]  2  3  4  5  6  7  8  9 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------</span></span><br><span class="line"></span><br><span class="line">x[c(2:6)] % 利用向量对数组进行切割</span><br><span class="line">x[c(2,6)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1] 2 3 4 5 6</span><br><span class="line">	[1] 2 6</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------</span></span><br><span class="line"></span><br><span class="line">x[c(-2,5)] % 当同时有负数与正数时将报错</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	Error <span class="keyword">in</span> y[c(-2, 5)] : 只有负下标里才能有零</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------</span></span><br><span class="line"></span><br><span class="line">x[c(T,F,F,T,F,F,F,F,T,T)] % 利用逻辑值对X数组进行操作</span><br><span class="line"></span><br><span class="line">x[c(T)]</span><br><span class="line"></span><br><span class="line">x[c(F)]</span><br><span class="line"></span><br><span class="line">x[c(T,F)]	% 当给出逻辑值数目少于数组长度时，逻辑值将被循环判断</span><br><span class="line"></span><br><span class="line">x[c(T,F,T)]	% 当给出逻辑值数目少于数组长度时，逻辑值将被循环判断</span><br><span class="line"></span><br><span class="line">x[c(T,F,F,T,F,F,F,F,T,T,T,T,F)] % 当给出逻辑值数目大于数组长度时，多出的逻辑值为T则取NA(缺失值),为F不取值</span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line"></span><br><span class="line">	[1]  1  4  9 10</span><br><span class="line"></span><br><span class="line">	[1]  1  2  3  4  5  6  7  8  9 10</span><br><span class="line"></span><br><span class="line">	<span class="built_in">integer</span>(0)</span><br><span class="line"></span><br><span class="line">	[1] 1 3 5 7 9</span><br><span class="line"></span><br><span class="line">	[1]  1  3  4  6  7  9 10</span><br><span class="line"></span><br><span class="line">	[1]  1  4  9 10 NA NA</span><br></pre></td></tr></table></figure>
<p>也可以通过逻辑运算提取数组元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x[x&gt;5]</span><br><span class="line"></span><br><span class="line">x[x&gt;5 &amp; x&lt;9]</span><br><span class="line"></span><br><span class="line">x[x&gt;5 &amp; x&gt;9]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">	[1]  6  7  8  9 10</span><br><span class="line">	[1] 6 7 8</span><br><span class="line">	[1] 10</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h1><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵是一个二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）。可通过函数matrix()创建矩阵。一般使用格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myymatrix &lt;- matrix(vector, nrow=number_of_rows, ncol=number_of_columns, byrow=logical_value, dimnames=list(</span><br><span class="line"> char_vector_rownames, char_vector_colnames))</span><br></pre></td></tr></table></figure>
<p>其中vector包含了矩阵的元素，nrow和ncol用以指定行和列的维数，dimnames包含了可选的、以字符型向量表示的行名和列名。选项byrow则表明矩阵应当按行填充（byrow=TRUE）还是按列填充（byrow=FALSE），默认情况下按列填充。</p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>数组（array）与矩阵类似，但是维度可以大于2。数组可通过array函数创建，形式如下：</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myarray &lt;- array(vector, dimensions, dimnames)</span><br></pre></td></tr></table></figure>
<p>其中vector包含了数组中的数据，dimensions是一个数值型向量，给出了各个维度下标的最大值，而dimnames是可选的、各维度名称标签的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dim1 &lt;- c(<span class="string">"A1"</span>, <span class="string">"A2"</span>)</span><br><span class="line">&gt; dim2 &lt;- c(<span class="string">"B1"</span>, <span class="string">"B2"</span>, <span class="string">"B3"</span>)</span><br><span class="line">&gt; dim3 &lt;- c(<span class="string">"C1"</span>, <span class="string">"C2"</span>, <span class="string">"C3"</span>, <span class="string">"C4"</span>)</span><br><span class="line">&gt; z &lt;- array(1:24, c(2, 3, 4), dimnames=list(dim1, dim2, dim3))</span><br><span class="line"><span class="comment">#  z[1,2,3]==15</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h3><p>数据框不同的列可以包含不同模式（数值型、字符型等）的数据，所以其较矩阵来说更为一般。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">&gt; age &lt;- c(25, 34, 28, 52)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID, age, diabetes, status)</span><br><span class="line">&gt; patientdata</span><br><span class="line"></span><br><span class="line"> patientID age diabetes status</span><br><span class="line">1 1 25 Type1 Poor</span><br><span class="line">2 2 34 Type2 Improved</span><br><span class="line">3 3 28 Type1 Excellent</span><br><span class="line">4 4 52 Type1 Poor</span><br></pre></td></tr></table></figure>
<p>选取数据框中元素的方式有若干种。你可以使用前述（如矩阵中的）下标记号，亦可直接指定列名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; patientdata[1:2]</span><br><span class="line"> patientID age</span><br><span class="line">1 1 25</span><br><span class="line">2 2 34</span><br><span class="line">3 3 28</span><br><span class="line">4 4 52</span><br><span class="line"></span><br><span class="line">&gt; patientdata[c(<span class="string">"diabetes"</span>, <span class="string">"status"</span>)]</span><br><span class="line"> diabetes status</span><br><span class="line">1 Type1 Poor</span><br><span class="line">2 Type2 Improved</span><br><span class="line">3 Type1 Excellent</span><br><span class="line">4 Type1 Poor</span><br><span class="line"></span><br><span class="line"> &gt; patientdata<span class="variable">$age</span></span><br><span class="line">[1] 25 34 28 52</span><br></pre></td></tr></table></figure>
<p>第三个例子中的记号&lt;$&gt;被用来选取一个给定数据框中的某个特定变量。例如，如果你想生成糖尿病类型变量diabetes和病情变量status的列联表，使用以下代码即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; table(patientdata<span class="variable">$diabetes</span>, patientdata<span class="variable">$status</span>)</span><br><span class="line"> Excellent Improved Poor</span><br><span class="line"> Type1 1 0 2</span><br><span class="line"> Type2 0 1 0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用attach-、detach-和with-函数简化代码"><a href="#使用attach-、detach-和with-函数简化代码" class="headerlink" title="使用attach()、detach()和with()函数简化代码"></a>使用attach()、detach()和with()函数简化代码</h3><p>函数attach()[attach有”绑定”之意]可将数据框添加到R的搜索路径中。R在遇到一个变量名以后，将检查搜索路径中的数据框。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">summary(mtcars<span class="variable">$mpg</span>)</span><br><span class="line">plot(mtcars<span class="variable">$mpg</span>, mtcars<span class="variable">$disp</span>)</span><br><span class="line">plot(mtcars<span class="variable">$mpg</span>, mtcars<span class="variable">$wt</span>)</span><br><span class="line"><span class="comment">#----------------------以上代码可简化成：</span></span><br><span class="line">attach(mtcars)</span><br><span class="line"> summary(mpg)</span><br><span class="line"> plot(mpg, disp)</span><br><span class="line"> plot(mpg, wt)</span><br><span class="line">detach(mtcars) 	<span class="comment">#函数detach()将数据框从搜索路径中移除。值得注意的是，detach()并不会对数据框本身做任何处理。这句是可以省略的，但其实它应当被例行地放入代码中，因为这是一个好的编程习惯。</span></span><br></pre></td></tr></table></figure>
<p>当名称相同的对象不止一个时，这种方法的局限性就很明显了。考虑以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mpg &lt;- c(25, 36, 47)</span><br><span class="line">&gt; attach(mtcars)</span><br><span class="line">The following object(s) are masked _by_ <span class="string">'.GlobalEnv'</span>: mpg</span><br><span class="line">&gt; plot(mpg, wt)</span><br><span class="line">Error <span class="keyword">in</span> xy.coords(x, y, xlabel, ylabel, <span class="built_in">log</span>) :</span><br><span class="line"> <span class="string">'x'</span> and <span class="string">'y'</span> lengths differ</span><br><span class="line">&gt; mpg</span><br><span class="line">[1] 25 36 47 </span><br><span class="line"></span><br><span class="line"><span class="comment">#这里，在数据框mtcars被绑定（attach）之前，你们的环境中已经有了一个名为mpg的对象。在这种情况下，原始对象将取得优先权。由于mpg中有3个元素而disp中有32个元素，故plot语句出错。函数attach()和detach()最好在你分析一个单独的数据框，并且不太可能有多个同名对象时使用。**任何情况下，都要当心那些告知某个对象已被屏蔽（masked）的警告。**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------使用函数with()可以这样重写上例</span></span><br><span class="line"></span><br><span class="line">with(mtcars, &#123;</span><br><span class="line"> <span class="built_in">print</span>(summary(mpg))</span><br><span class="line"> plot(mpg, disp)</span><br><span class="line"> plot(mpg, wt)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">#在这种情况下，花括号&#123;&#125;之间的语句都针对数据框mtcars执行，这样就无需担心名称冲突了。如果仅有一条语句（例如summary(mpg)），那么花括号&#123;&#125;可以省略。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------函数with()的局限性在于，赋值仅在此函数的括号内生效。</span></span><br><span class="line"></span><br><span class="line">&gt; with(mtcars, &#123;</span><br><span class="line"> stats &lt;- summary(mpg)</span><br><span class="line"> stats</span><br><span class="line"> &#125;)</span><br><span class="line"> Min. 1st Qu. Median Mean 3rd Qu. Max.</span><br><span class="line"> 10.40 15.43 19.20 20.09 22.80 33.90</span><br><span class="line">&gt; stats</span><br><span class="line">Error: object <span class="string">'stats'</span> not found </span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------如果你需要创建在with()结构以外存在的对象，使用特殊赋值符(&lt;&lt;-)替代标准赋值符（&lt;-）即可，它可将对象保存到with()之外的全局环境中。</span></span><br><span class="line"></span><br><span class="line">&gt; with(mtcars, &#123;</span><br><span class="line"> nokeepstats &lt;- summary(mpg)</span><br><span class="line"> keepstats &lt;&lt;- summary(mpg)</span><br><span class="line">&#125;)</span><br><span class="line">&gt; nokeepstats</span><br><span class="line">Error: object <span class="string">'nokeepstats'</span> not found</span><br><span class="line">&gt; keepstats</span><br><span class="line"> Min. 1st Qu. Median Mean 3rd Qu. Max.</span><br><span class="line"> 10.40 15.43 19.20 20.09 22.80 33.90</span><br></pre></td></tr></table></figure>
<ul>
<li>实例标识符<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">&gt; age &lt;- c(25, 34, 28, 52)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID, age, diabetes, status)</span><br><span class="line">&gt; patientdata </span><br><span class="line">  patientID age diabetes    status</span><br><span class="line">1         1  25    Type1      Poor</span><br><span class="line">2         2  34    Type2  Improved</span><br><span class="line">3         3  28    Type1 Excellent</span><br><span class="line">4         4  52    Type1      Poor</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------在病例数据中，病人编号（patientID）用于区分数据集中不同的个体。在R中，实例标识符（case identifier）可通过数据框操作函数中的rowname选项指定。</span></span><br><span class="line"></span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID, age, diabetes,status, row.names=age) </span><br><span class="line">&gt; patientdata</span><br><span class="line">   patientID age diabetes    status</span><br><span class="line">25         1  25    Type1      Poor</span><br><span class="line">34         2  34    Type2  Improved</span><br><span class="line">28         3  28    Type1 Excellent</span><br><span class="line">52         4  52    Type1      Poor</span><br><span class="line"><span class="comment">#将patientID指定为R中标记各类打印输出和图形中实例名称所用的变量。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h3><p>变量可归结为名义型、有序型或连续型变量。</p>
<ol>
<li>名义型变量是没有顺序之分的类别变量。糖尿病类型Diabetes（Type1、Type2）是名义型变量的一例。即使在数据中Type1编码为1而Type2编码为2，这也并不意味着二者是有序的。</li>
<li>有序型变量表示一种顺序关系，而非数量关系。病情Status（poor、improved、excellent）是顺序型变量的一个上佳示例。我们明白，病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。</li>
<li>连续型变量可以呈现为某个范围内的任意值，并同时表示了顺序和数量。年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值。</li>
</ol>
<p><strong>类别（名义型）变量</strong>和<strong>有序类别（有序型）变量</strong>在R中称为<strong>因子（factor）</strong>。<strong>因子在R中非常重要，因为它决定了数据的分析方式以及如何进行视觉呈现</strong>。</p>
<p>函数factor()以一个整数向量的形式存储类别值，整数的取值范围是[1…k]（其中k是名义型变量中唯一值的个数），同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</p>
<ul>
<li><p>对于<strong>字符型向量</strong>，因子的水平默认<strong>依字母顺序创建</strong>。但按默认的字母顺序排序的因子很少能够让人满意。你可以通过指定levels选项来覆盖默认排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">&gt; status &lt;- factor(status, order=TRUE,levels=c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>))</span><br><span class="line">&gt; status</span><br><span class="line">[1] Poor Improved Excellent Poor     </span><br><span class="line">Levels: Poor &lt; Improved &lt; Excellent</span><br><span class="line"><span class="comment">#各水平的赋值将为1=Poor、2=Improved、3=Excellent。必须保证指定的水平与数据中的真实值相匹配，否则任何在数据中出现而未在参数中列举的数据都将被设为缺失值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数值型变量可以用levels和labels参数来编码成因子。如果男性被编码成1，女性被编码成2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sex &lt;- c(1,2,1,1)</span><br><span class="line">&gt; sex &lt;- factor(sex, levels=c(1, 2), labels=c(<span class="string">"Male"</span>, <span class="string">"Female"</span>))</span><br><span class="line">&gt; sex</span><br><span class="line">[1] Male Female Male Male  </span><br><span class="line">Levels: Male Female</span><br></pre></td></tr></table></figure>
<p>以下代码演示了普通因子和有序因子的不同是如何影响数据分析的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">&gt; age &lt;- c(25, 34, 28, 52)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">&gt; diabetes &lt;- factor(diabetes)</span><br><span class="line">&gt; status &lt;- factor(status, order=TRUE)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID, age, diabetes, status) </span><br><span class="line"></span><br><span class="line">&gt; str(patientdata) </span><br><span class="line"><span class="string">'data.frame'</span>:	4 obs. of  4 variables:</span><br><span class="line"> $ patientID: num  1 2 3 4</span><br><span class="line"> $ age      : num  25 34 28 52</span><br><span class="line"> $ diabetes : Factor w/ 2 levels <span class="string">"Type1"</span>,<span class="string">"Type2"</span>: 1 2 1 1</span><br><span class="line"> $ status   : Ord.factor w/ 3 levels <span class="string">"Excellent"</span>&lt;<span class="string">"Improved"</span>&lt;..: 3 2 1 3</span><br><span class="line"></span><br><span class="line"> &gt; summary(patientdata)</span><br><span class="line">   patientID         age         diabetes</span><br><span class="line"> Min.   :1.00   Min.   :25.00   Type1:3  </span><br><span class="line"> 1st Qu.:1.75   1st Qu.:27.25   Type2:1  </span><br><span class="line"> Median :2.50   Median :31.00            </span><br><span class="line"> Mean   :2.50   Mean   :34.75            </span><br><span class="line"> 3rd Qu.:3.25   3rd Qu.:38.50            </span><br><span class="line"> Max.   :4.00   Max.   :52.00  </span><br><span class="line"></span><br><span class="line">       status </span><br><span class="line"> Excellent:1  </span><br><span class="line"> Improved :1  </span><br><span class="line"> Poor     :2</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------</span></span><br><span class="line"></span><br><span class="line">&gt; patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">&gt; age &lt;- c(25, 34, 28, 52)</span><br><span class="line">&gt; diabetes &lt;- c(<span class="string">"Type1"</span>, <span class="string">"Type2"</span>, <span class="string">"Type1"</span>, <span class="string">"Type1"</span>)</span><br><span class="line">&gt; status &lt;- c(<span class="string">"Poor"</span>, <span class="string">"Improved"</span>, <span class="string">"Excellent"</span>, <span class="string">"Poor"</span>)</span><br><span class="line">&gt; patientdata &lt;- data.frame(patientID, age, diabetes, status)</span><br><span class="line"></span><br><span class="line">&gt; str(patientdata) </span><br><span class="line"><span class="string">'data.frame'</span>:	4 obs. of  4 variables:</span><br><span class="line"> $ patientID: num  1 2 3 4</span><br><span class="line"> $ age      : num  25 34 28 52</span><br><span class="line"> $ diabetes : chr  <span class="string">"Type1"</span> <span class="string">"Type2"</span> <span class="string">"Type1"</span> <span class="string">"Type1"</span></span><br><span class="line"> $ status   : chr  <span class="string">"Poor"</span> <span class="string">"Improved"</span> <span class="string">"Excellent"</span> <span class="string">"Poor"</span></span><br><span class="line"></span><br><span class="line">&gt; summary(patientdata)</span><br><span class="line">   patientID         age          diabetes        </span><br><span class="line"> Min.   :1.00   Min.   :25.00   Length:4          </span><br><span class="line"> 1st Qu.:1.75   1st Qu.:27.25   Class :character  </span><br><span class="line"> Median :2.50   Median :31.00   Mode  :character  </span><br><span class="line"> Mean   :2.50   Mean   :34.75                     </span><br><span class="line"> 3rd Qu.:3.25   3rd Qu.:38.50                     </span><br><span class="line"> Max.   :4.00   Max.   :52.00 </span><br><span class="line"></span><br><span class="line">    status         </span><br><span class="line"> Length:4          </span><br><span class="line"> Class :character  </span><br><span class="line"> Mode  :character</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表（list）是R的数据类型中最为复杂的一种。一般来说，列表就是一些对象（或成分，component）的有序集合。列表允许你整合若干（可能无关的）对象到单个对象名下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; g &lt;- <span class="string">"My First List"</span></span><br><span class="line">&gt; h &lt;- c(25, 26, 18, 39)</span><br><span class="line">&gt; j &lt;- matrix(1:10, nrow=5)</span><br><span class="line">&gt; k &lt;- c(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line">&gt; mylist &lt;- list(title=g, ages=h, j, k)</span><br><span class="line">&gt; mylist</span><br><span class="line"><span class="variable">$title</span></span><br><span class="line">[1] <span class="string">"My First List"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ages</span></span><br><span class="line">[1] 25 26 18 39</span><br><span class="line"></span><br><span class="line">[[3]]</span><br><span class="line">     [,1] [,2]</span><br><span class="line">[1,]    1    6</span><br><span class="line">[2,]    2    7</span><br><span class="line">[3,]    3    8</span><br><span class="line">[4,]    4    9</span><br><span class="line">[5,]    5   10</span><br><span class="line"></span><br><span class="line">[[4]]</span><br><span class="line">[1] <span class="string">"one"</span>   <span class="string">"two"</span>   <span class="string">"three"</span></span><br><span class="line"><span class="comment">#----------下面输出第三个成分</span></span><br><span class="line">&gt; mylist[[2]]</span><br><span class="line">[1] 25 26 18 39</span><br><span class="line">&gt; mylist[[<span class="string">"ages"</span>]]</span><br><span class="line">[1] 25 26 18 39</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="程序员注意事项"><a href="#程序员注意事项" class="headerlink" title="程序员注意事项"></a>程序员注意事项</h3><ul>
<li><p>R不提供多行注释或块注释功能。你必须以#作为多行注释每行的开始。出于调试目的，你也可以把想让解释器忽略的代码放到语句if(FALSE){… }中。将FALSE改为TRUE即允许这块代码执行。</p>
</li>
<li><p>将一个值赋给某个向量、矩阵、数组或列表中一个不存在的元素时，R将自动扩展这个数据结构以容纳新值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- c(8, 6, 4)</span><br><span class="line">&gt; x[7] &lt;- 10</span><br><span class="line">&gt; x</span><br><span class="line">[1] 8 6 4 NA NA NA 10</span><br></pre></td></tr></table></figure>
<p>通过赋值，向量x由三个元素扩展到了七个元素。x &lt;- x[1:3]会重新将其缩减回三个元素。</p>
</li>
<li><p>R中没有标量。标量以单元素向量的形式出现。</p>
</li>
<li><p>R中的下标不从0开始，而从1开始。在上述向量中，x[1]的值为8。</p>
</li>
<li><p>变量无法被声明。它们在首次被赋值时生成。</p>
</li>
</ul>
<hr>
<h1 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h1><h3 id="使用键盘输入数据"><a href="#使用键盘输入数据" class="headerlink" title="使用键盘输入数据"></a>使用键盘输入数据</h3><p>使用键盘输入数据有两种常见的方式：<strong>用R内置的文本编辑器</strong>和<strong>直接在代码中嵌入数据</strong>。</p>
<ol>
<li>R中的函数edit()会自动调用一个允许手动输入数据的文本编辑器。具体步骤如下：(1) 创建一个空数据框（或矩阵），其中变量名和变量的模式需与理想中的最终数据集一致；(2) 针对这个数据对象调用文本编辑器，输入你的数据，并将结果保存回此数据对象中。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mydata &lt;- data.frame(age = numeric(0),gender = character(0),weight = numeric(0))</span><br><span class="line"><span class="comment"># 以上例子创建一个名为mydata的数据框，它含有三个*空变量*：age（数值型）、gender（字符型）和weight（数值型）。</span></span><br><span class="line">&gt; mydata &lt;- edit(mydata) <span class="comment">#调用文本编辑器输入数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>类似于age=numeric(0)的赋值语句将创建一个指定模式但不含实际数据的变量。</li>
<li><strong>编辑的结果需要赋值回对象本身</strong>。函数edit()事实上是在对象的一个副本上进行操作的。<strong>如果你不将其赋值到一个目标，你的所有修改将会全部丢失</strong>！</li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>R语言 基础语法</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2020/07/14/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="使用-进行本地预览"><a href="#使用-进行本地预览" class="headerlink" title="使用  进行本地预览"></a>使用 <hexo s> 进行本地预览</hexo></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<h2 id="使用-清除缓存文件和已生成的静态文件"><a href="#使用-清除缓存文件和已生成的静态文件" class="headerlink" title="使用  清除缓存文件和已生成的静态文件"></a>使用 <hexo clean> 清除缓存文件和已生成的静态文件</hexo></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 清除缓存文件db.json 和已生成的静态文件public</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-hexo-generate的简写形式-生成静态文件"><a href="#使用-hexo-generate的简写形式-生成静态文件" class="headerlink" title="使用  (hexo generate的简写形式)生成静态文件"></a>使用 <hexo g> (hexo generate的简写形式)生成静态文件</hexo></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 是hexo generate的简写形式，生成静态文件到public文件夹</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-hexo-deploy的简写形式-部署静态文件到设定的仓库"><a href="#使用-hexo-deploy的简写形式-部署静态文件到设定的仓库" class="headerlink" title="使用  (hexo deploy的简写形式)部署静态文件到设定的仓库"></a>使用 <hexo d> (hexo deploy的简写形式)部署静态文件到设定的仓库</hexo></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d <span class="comment"># 是hexo deploy的简写形式，部署静态文件到设定的仓库</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-lt-hexo-clean-amp-amp-hexo-g-amp-amp-hexo-d-gt-进行一步操作"><a href="#使用-lt-hexo-clean-amp-amp-hexo-g-amp-amp-hexo-d-gt-进行一步操作" class="headerlink" title="使用 &lt;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&gt; 进行一步操作"></a>使用 &lt;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&gt; 进行一步操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d <span class="comment"># 常用的组合命令，清除缓存，生成静态文件，并部署到指定仓库</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-lt-hexo-new-draft-“new-draft-File-Name-”-gt-创建草稿（私密文章）"><a href="#使用-lt-hexo-new-draft-“new-draft-File-Name-”-gt-创建草稿（私密文章）" class="headerlink" title="使用 &lt;hexo new draft “new draft(File Name)”&gt; 创建草稿（私密文章）"></a>使用 &lt;hexo new draft “new draft(File Name)”&gt; 创建草稿（私密文章）</h2><ul>
<li>输入创建草稿命令，系统会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。相当于很多博客都有的“私密文章”功能。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft(File Name)"</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/2020/07/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="关于使用get-和getline-函数将整行的字符串输入储存在数组的注意事项"><a href="#关于使用get-和getline-函数将整行的字符串输入储存在数组的注意事项" class="headerlink" title="关于使用get()和getline()函数将整行的字符串输入储存在数组的注意事项"></a>关于使用<em>get()</em>和<em>getline()</em>函数将<strong>整行的字符串输入</strong>储存在数组的注意事项</h3><ul>
<li><p>两者区别：两者都通过换行符来确定输入的结尾，不同之处在于，在到达换行符后，<strong>getline()将丢弃换行符，而get()将换行符保留在输入流中。</strong></p>
</li>
<li><p><em>getline(name,num)</em>函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。name为存储输入行的数组名，num为要读取的字符数。getline()最多读取(num-1)个字符数，余下的空间用于储存’\0’字符。getline()成员函数在读取指定数目的字符或遇到换行符时停止读取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int num = 10;</span><br><span class="line">    char a[num];</span><br><span class="line">    char b[num];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"your a's name is: \n"</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">"your b's name is: \n"</span>;</span><br><span class="line">    cin.getline(a,num);</span><br><span class="line">    cin.getline(b,num);</span><br><span class="line"><span class="comment">#   cin.getline(a,num).getline(b,num); 上面两行代码也可以用这行代码代替</span></span><br><span class="line">    cout&lt;&lt;<span class="string">"your a name is: "</span>&lt;&lt;a&lt;&lt;<span class="string">",your b name is: "</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>get(name,num)</em>函数有与会将换行符保留在输入流中，所以需要借助一些额外操作使程序正常运行。</p>
</li>
</ul>
<ol>
<li>使用不带任何参数的cin.get()的调用可读取下一个字符(即使是换行符)，为读取下一行做准备。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int num = 10;</span><br><span class="line">    char a[num];</span><br><span class="line">    char b[num];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"your a's name is: \n"</span>;</span><br><span class="line">    cin.get(a,num);</span><br><span class="line">    cin.get();</span><br><span class="line">    cout&lt;&lt;<span class="string">"your b's name is: \n"</span>;</span><br><span class="line">    cin.get(b,num);</span><br><span class="line">    cout&lt;&lt;<span class="string">"your a name is: "</span>&lt;&lt;a&lt;&lt;<span class="string">",your b name is: "</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将两个类成员函数拼接起来<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int num = 10;</span><br><span class="line">    char a[num];</span><br><span class="line">    char b[num];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">"your a's name is: \n"</span>;</span><br><span class="line">    cin.get(a,num).get();</span><br><span class="line">    cout&lt;&lt;<span class="string">"your b's name is: \n"</span>;</span><br><span class="line">    cin.get(b,num);</span><br><span class="line">    cout&lt;&lt;<span class="string">"your a name is: "</span>&lt;&lt;a&lt;&lt;<span class="string">",your b name is: "</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>C++ 基础语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中copy与deepcopy的区别</title>
    <url>/2020/05/09/Python%E4%B8%ADcopy%E4%B8%8Edeepcopy%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>copy与deepcopy都在copy模块中，使用的时候需要实现导入copy包,以下为示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">a = [1, 2]</span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(b), id(c), id(d))</span><br><span class="line"><span class="comment">#[out]:</span></span><br><span class="line">	2480148669704 2480148669704 2480148617096 2479872285064</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">a = 22</span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(b), id(c), id(d))</span><br><span class="line"><span class="comment"># [out]:</span></span><br><span class="line">	140731869655968 140731869655968 140731869655968 140731869655968</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>赋值语句</strong>：赋值，并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。</p>
</li>
<li><p><strong>对于不可变类型（数值，字符串，元组）</strong>：浅复制、深复制和“等于赋值”的情况一样，对象的id值与原来的值相同，都是将对象指向同一个引用。</p>
</li>
</ol>
<hr>
<p><strong>对于可变类型（列表和字典）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">a = [1, 2, [1, 2]]</span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(b), id(c), id(d))</span><br><span class="line"></span><br><span class="line">a[0] = 2</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(b), id(c), id(d))</span><br><span class="line"></span><br><span class="line">a[2][0] = 5</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(b), id(c), id(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#[out]:</span></span><br><span class="line">[1, 2, [1, 2]] [1, 2, [1, 2]] [1, 2, [1, 2]] [1, 2, [1, 2]]</span><br><span class="line">1292062431112 1292062431112 1291786145352 1291786145608</span><br><span class="line">[2, 2, [1, 2]] [2, 2, [1, 2]] [1, 2, [1, 2]] [1, 2, [1, 2]]</span><br><span class="line">1292062431112 1292062431112 1291786145352 1291786145608</span><br><span class="line">[2, 2, [5, 2]] [2, 2, [5, 2]] [1, 2, [5, 2]] [1, 2, [1, 2]]</span><br><span class="line">1292062431112 1292062431112 1291786145352 1291786145608</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>浅复制copy.copy(): 只拷贝父对象，不会拷贝对象的内部的子对象。</strong></li>
</ol>
<ul>
<li>第一种情况(无复杂子对象):原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。</li>
<li>第二种情况(有复杂子对象):（例如列表中的一个子元素是一个列表），如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 但是改变原来的值中的复杂子对象的值会影响浅复制的值， 因为他们子对象的引用是一样的。</li>
</ul>
<ol start="2">
<li><strong>深复制deepcopy.copy()：拷贝父对象以及拷贝对象的内部的子对象,索引值都不同。</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">a = [1, 2, [1, 2]]</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(id(a), id(c))</span><br><span class="line"><span class="built_in">print</span>(id(a[2]), id(c[2]))</span><br><span class="line"><span class="comment">#[out]:</span></span><br><span class="line">	1828100118472 1827823832200</span><br><span class="line">	1828100146760 1827823754632</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《python深度学习》笔记</title>
    <url>/2020/05/08/%E3%80%8Apython%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一章-什么是深度学习"><a href="#第一章-什么是深度学习" class="headerlink" title="第一章 什么是深度学习"></a>第一章 什么是深度学习</h1><h2 id="1-1-人工智能、机器学习与深度学习"><a href="#1-1-人工智能、机器学习与深度学习" class="headerlink" title="1.1　人工智能、机器学习与深度学习"></a><strong>1.1　人工智能、机器学习与深度学习</strong></h2><blockquote>
<p>人工智能、机器学习与深度学习这三者之间的关系：{深度学习}&lt;{机器学习}&lt;{人工智能}</p>
</blockquote>
<h3 id="1-1-1-人工智能"><a href="#1-1-1-人工智能" class="headerlink" title="1.1.1　人工智能"></a>1.1.1　人工智能</h3><ul>
<li>人工智能的简洁定义如下：<strong>努力将通常由人类完成的智力任务自动化。</strong>因此，<strong>人工智能是一个综合性的领域，不仅包括机器学习与深度学习，还包括更多不涉及学习的方法</strong>。</li>
</ul>
<h3 id="1-1-2-机器学习"><a href="#1-1-2-机器学习" class="headerlink" title="1.1.2　机器学习"></a>1.1.2　机器学习</h3><ul>
<li><p>在经典的程序设计（即符号主义人工智能的范式）中，人们<strong>输入的是规则（即程序）</strong>和需要根据这些规则<strong>进行处理的数据</strong>，系统<strong>输出的是答案</strong>。</p>
</li>
<li><p>在机器学习中，人们<strong>输入的是数据</strong>和从这些数据中<strong>预期得到的答案</strong>，系统<strong>输出的是规则</strong>。这些规则随后可应用于新的数据，并使计算机自主生成答案。</p>
</li>
<li><p>机器学习系统是<strong>训练出来的</strong>，而不是明确地用程序编写出来的。</p>
</li>
<li><p>机器学习（尤其是深度学习）呈现出相对较少的数学理论（可能太少了），并且是以工程为导向的。这是一门<strong>需要上手实践的学科</strong>，想法<strong>更多地是靠实践来证明</strong>，而不是靠理论推导。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="1-1-3-从数据中学习表示"><a href="#1-1-3-从数据中学习表示" class="headerlink" title="1.1.3　从数据中学习表示"></a>1.1.3　从数据中学习表示</h3><ul>
<li><p>机器学习和深度学习的核心问题在于<strong>有意义地变换数据</strong>，换句话说，在于学习输入数据的<strong>有用表示（representation）</strong>——这种表示可以让数据更接近预期输出。</p>
</li>
<li><p>什么是<strong>表示</strong>：这一概念的核心在于<strong>以一种不同的方式来查看数据（即表征数据或将数据编码）</strong>。例如，彩色图像可以编码为RGB（红-绿-蓝）格式或HSV（色相-饱和度-明度）格式，这是对相同数据的两种不同表示。在处理某些任务时，使用某种表示可能会很困难，但换用另一种表示就会变得很简单。</p>
</li>
<li><p>所有机器学习算法都包括<strong>自动寻找这样一种变换</strong>：这种变换可以根据任务将数据转化为更加有用的表示。机器学习算法在寻找这些变换时通常没有什么创造性，而仅仅是遍历一组预先定义好的操作，这组操作叫作<strong>假设空间（hypothesis space）</strong>。</p>
</li>
<li><p>这就是机器学习的技术定义：<strong>在预先定义好的可能性空间中，利用反馈信号的指引来寻找输入数据的有用表示</strong>。</p>
</li>
</ul>
<h3 id="1-1-4-深度学习之“深度”"><a href="#1-1-4-深度学习之“深度”" class="headerlink" title="1.1.4　深度学习之“深度”"></a>1.1.4　深度学习之“深度”</h3><ul>
<li><p>深度学习是机器学习的一个分支领域：它是从数据中学习表示的一种新方法，强调从连续的<strong>层（layer）</strong>中进行学习，这些层对应于<strong>越来越有意义的表示</strong>。</p>
</li>
<li><p>“深度学习”中的“深度”指的并不是利用这种方法所获取的更深层次的理解，而是指<strong>一系列连续的表示层</strong>。数据模型中包含多少层，这被称为模型的<strong>深度（depth）</strong>。这一领域的其他名称包括分层表示学习（layered representations learning）和层级表示学习（hierarchical representations learning）。</p>
</li>
<li><p>现代深度学习通常包含<strong>数十个甚至上百个连续的表示层</strong>，这些表示层全都是从训练数据中自动学习的。与此相反，其他机器学习方法的重点往往是仅仅学习一两层的数据表示，因此有时也被称为<strong>浅层学习（shallow learning）</strong>。</p>
</li>
<li><p>在深度学习中，这些分层表示几乎总是通过叫作<strong>神经网络（neural network）</strong>的模型来学习得到的。</p>
</li>
</ul>
<h3 id="1-1-5-理解深度学习的工作原理"><a href="#1-1-5-理解深度学习的工作原理" class="headerlink" title="1.1.5　理解深度学习的工作原理"></a>1.1.5　理解深度学习的工作原理</h3><ul>
<li><p>神经网络中每层对输入数据所做的具体操作保存在该层的<strong>权重（weight）</strong>中，其本质是一串数字。用术语来说，每层实现的变换由其权重来<strong>参数化（parameterize，见图 1-7）</strong>。权重有时<br>也被称为该层的<strong>参数（parameter）</strong>。在这种语境下，学习的意思是<strong>为神经网络的所有层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应</strong>。</p>
</li>
<li><p>想要控制神经网络的输出，就需要能够衡量该输出与预期值之间的距离。这是神经网络<strong>损失函数（loss function）</strong>的任务，该函数也叫<strong>目标函数（objective function）</strong>。损失函数的输入是网络预测值与真实目标值（即你希望网络输出的结果），然后计算一个距离值，衡量该网络在这个示例上的效果好坏。</p>
</li>
<li><p>深度学习的基本技巧是利用这个距离值作为反馈信号来对权重值进行微调，以降低当前示例对应的损失值。这种调节由<strong>优化器（optimizer）</strong>来完成，它实现了所谓的<strong>反向传播（backpropagation）算法</strong>，这是深度学习的<strong>核心算法</strong>。</p>
</li>
</ul>
<h3 id="1-1-8-人工智能的未来"><a href="#1-1-8-人工智能的未来" class="headerlink" title="1.1.8　人工智能的未来"></a>1.1.8　人工智能的未来</h3><ul>
<li><strong>不要相信短期的炒作，但一定要相信长期的愿景。人工智能可能需要一段时间才能充分发挥其潜力。这一潜力的范围大到难以想象，但人工智能终将到来，它将以一种奇妙的方式改变我们的世界。</strong></li>
</ul>
<h2 id="1-2-深度学习之前：机器学习简史"><a href="#1-2-深度学习之前：机器学习简史" class="headerlink" title="1.2　深度学习之前：机器学习简史"></a><strong>1.2　深度学习之前：机器学习简史</strong></h2><blockquote>
<p>深度学习已经得到了人工智能历史上前所未有的公众关注度和产业投资，但这并不是机器学习的第一次成功。可以这样说，当前工业界所使用的绝大部分机器学习算法都不是深度学习算法。深度学习不一定总是解决问题的正确工具：有时没有足够的数据，深度学习不适用；有时用其他算法可以更好地解决问题。如果你第一次接触的机器学习就是深度学习，那你可能会发现手中握着一把深度学习“锤子”，而所有机器学习问题看起来都像是“钉子”。为了避免陷入这个误区，唯一的方法就是熟悉其他机器学习方法并在适当的时候进行实践。</p>
</blockquote>
<h3 id="1-2-1-概率建模"><a href="#1-2-1-概率建模" class="headerlink" title="1.2.1　概率建模"></a>1.2.1　概率建模</h3><ul>
<li><p><strong>概率建模（probabilistic modeling）</strong>是统计学原理在数据分析中的应用。它是最早的机器学习形式之一，至今仍在广泛使用。</p>
</li>
<li><p>其中最有名的算法之一就是<strong>朴素贝叶斯算法</strong>:它假设输入数据的特征都是独立的。这是一个很强的假设，或者说“朴素的”假设，其名称正来源于此。</p>
</li>
<li><p>另一个密切相关的<strong>分类算法</strong>模型是 <strong>logistic 回归（logistic regression，简称 logreg）</strong>，它有时被认为是现代机器学习的“hello world”。面对一个数据集，数据科学家<strong>通常会首先尝试使用这个算法</strong>，以便初步熟悉手头的分类任务。</p>
</li>
</ul>
<h3 id="1-2-2-早期神经网络"><a href="#1-2-2-早期神经网络" class="headerlink" title="1.2.2　早期神经网络"></a>1.2.2　早期神经网络</h3><ul>
<li>反向传播算法——一种利用梯度下降优化来训练一系列参数化运算链的方法（笔记后面将给出这些概念的具体定义）</li>
</ul>
<h3 id="1-2-3-核方法"><a href="#1-2-3-核方法" class="headerlink" title="1.2.3　核方法"></a>1.2.3　核方法</h3><ul>
<li><p>核方法是一组分类算法，其中最有名的就是<strong>支持向量机（SVM，support vector machine）</strong>。</p>
</li>
<li><p>SVM 的目标是通过在属于两个不同类别的两组数据点之间找到良好<strong>决策边界（decisionboundary）</strong>来解决分类问题。</p>
</li>
<li><p>SVM 通过两步来寻找决策边界:</p>
</li>
</ul>
<ol>
<li>将数据映射到一个新的高维表示，这时决策边界可以用一个超平面来表示（如果数据是二维的，那么超平面就是一条直线）。</li>
<li>尽量让超平面与每个类别最近的数据点之间的<strong>距离最大化</strong>，从而计算出良好决策边界（分割超平面），这一步叫作<strong>间隔最大化（maximizing the margin）</strong>。</li>
</ol>
<ul>
<li><p>将数据映射到高维表示从而使分类问题简化，这一技巧可能听起来很不错，但在实践中通常是难以计算的。这时就需要用到<strong>核技巧（kernel trick，核方法正是因这一核心思想而得名）</strong>。其基本思想是：要想在新的表示空间中找到良好的决策超平面，你不需要在新空间中直接计算点的坐标，只需要在新空间中计算点对之间的距离，而利用<strong>核函数（kernel function）</strong>可以高效地完成这种计算。核函数是一个在计算上能够实现的操作，将原始空间中的任意两点映射为这两点在目标表示空间中的距离，完全避免了对新表示进行直接计算。核函数通常是人为选择的，而不是从数据中学到的。对于 SVM 来说，只有分割超平面是通过学习得到的。</p>
</li>
<li><p>SVM 很难扩展到大型数据集，并且在图像分类等感知问题上的效果也不好。SVM是一种比较浅层的方法，因此要想将其应用于感知问题，首先需要手动提取出有用的表示（这叫作<strong>特征工程</strong>），这一步骤很难，而且不稳定。</p>
</li>
</ul>
<h3 id="1-2-4-决策树、随机森林与梯度提升机"><a href="#1-2-4-决策树、随机森林与梯度提升机" class="headerlink" title="1.2.4　决策树、随机森林与梯度提升机"></a>1.2.4　决策树、随机森林与梯度提升机</h3><ul>
<li><strong>梯度提升方法</strong>可能是目前处理<strong>非感知数据</strong>最好的算法之一（如果非要加个“之一”的话）。</li>
</ul>
<h3 id="1-2-7-机器学习现状"><a href="#1-2-7-机器学习现状" class="headerlink" title="1.2.7　机器学习现状"></a>1.2.7　机器学习现状</h3><ul>
<li>梯度提升机用于<strong>处理结构化数据的问题</strong>，而深度学习则用于<strong>图像分类等感知问题</strong>。使用前一种方法的人几乎都使用优秀的<strong>XGBoost库</strong>，它同时支持数据科学最流行的两种语言：Python 和 R。使用深度学习的 Kaggle 参赛者则大多使用 <strong>Keras 库</strong>，因为它易于使用，非常灵活，并且支持Python。</li>
</ul>
<h2 id="1-3-为什么是深度学习，为什么是现在"><a href="#1-3-为什么是深度学习，为什么是现在" class="headerlink" title="1.3　为什么是深度学习，为什么是现在"></a><strong>1.3　为什么是深度学习，为什么是现在</strong></h2><blockquote>
<p>由于这一领域是靠实验结果而不是理论指导的，所以只有当合适的数据和硬件可用于尝试新想法时（或者将旧想法的规模扩大，事实往往也是如此），才可能出现算法上的改进。<strong>机器学习不是数学或物理学，靠一支笔和一张纸就能实现重大进展。它是一门工程科学</strong>。在 20 世纪 90 年代和 21 世纪前十年，真正的瓶颈在于数据和硬件。但在这段时间内发生了下面这些事情：互联网高速发展，并且针对游戏市场的需求开发出了高性能图形芯片。</p>
</blockquote>
<hr>
<h1 id="第二章-神经网络的数学基础"><a href="#第二章-神经网络的数学基础" class="headerlink" title="第二章 神经网络的数学基础"></a>第二章 神经网络的数学基础</h1><h2 id="2-2-神经网络的数据表示"><a href="#2-2-神经网络的数据表示" class="headerlink" title="2.2　神经网络的数据表示"></a><strong>2.2　神经网络的数据表示</strong></h2><blockquote>
<p>数据存储在多维 Numpy 数组中，也叫<strong>张量（tensor）</strong>。矩阵是二维张量,张量是矩阵向任意维度的推广［注意:张量的<strong>维度（dimension）</strong>通常叫作<strong>轴（axis）</strong>］。</p>
</blockquote>
<h3 id="2-2-1-标量（0D-张量）"><a href="#2-2-1-标量（0D-张量）" class="headerlink" title="2.2.1　标量（0D 张量）"></a>2.2.1　标量（0D 张量）</h3><ul>
<li><p>仅包含一个数字的张量叫作<strong>标量</strong>（scalar，也叫<strong>标量张量、零维张量、0D 张量</strong>）。</p>
</li>
<li><p>你可以用 ndim 属性来查看一个 Numpy 张量的轴的个数。标量张量有 0 个轴（ndim == 0）。张量轴的个数也叫作<strong>阶（rank）</strong>。下面展示一个 Numpy 标量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; x = np.array(12)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array(12)</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-2-向量（1D-张量）"><a href="#2-2-2-向量（1D-张量）" class="headerlink" title="2.2.2　向量（1D 张量）"></a>2.2.2　向量（1D 张量）</h3><ul>
<li><p>数字组成的数组叫作<strong>向量（vector）</strong>或<strong>一维张量（1D 张量）</strong>。一维张量只有一个轴,下面是一个 Numpy 向量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([12, 3, 6, 14, 7])</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array([12, 3, 6, 14, 7])</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个<strong>向量</strong>有 5 个元素，所以被称为 <strong>5D 向量</strong>。不要把<strong>5D 向量</strong>和 <strong><em>5D 张量</em></strong>弄混！ <strong>5D 向量</strong>只有一个轴，沿着轴有 5 个维度，而 <strong><em>5D 张量</em></strong>有 5 个轴（沿着每个轴可能有任意个维度）。<strong>维度（dimensionality）</strong>可以表示沿着某个轴上的元素个数（比如 5D 向量），也可以表示张量中轴的个数（比如 5D 张量），这有时会令人感到混乱。对于后一种情况，技术上更准确的说法是 <strong>5 阶张量</strong>（张量的阶数即轴的个数），但 5D 张量这种模糊的写法更常见。</p>
</li>
</ul>
<h3 id="2-2-3-矩阵（2D-张量）"><a href="#2-2-3-矩阵（2D-张量）" class="headerlink" title="2.2.3　矩阵（2D 张量）"></a>2.2.3　矩阵（2D 张量）</h3><ul>
<li>向量组成的数组叫作<strong>矩阵（matrix）</strong>或<strong>二维张量（2D 张量）</strong>。矩阵有 <strong>2 个轴</strong>（通常叫作<strong>行</strong>和<strong>列</strong>）。你可以将矩阵直观地理解为数字组成的矩形网格。下面是一个 Numpy 矩阵.<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([[5, 78, 2, 34, 0],</span><br><span class="line"> [6, 79, 3, 35, 1],</span><br><span class="line"> [7, 80, 4, 36, 2]])</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
第一个轴上的元素叫作行（row），第二个轴上的元素叫作列（column）。在上面的例子中，[5, 78, 2, 34, 0] 是 x 的第一行，[5, 6, 7] 是第一列。</li>
</ul>
<h3 id="2-2-4-3D-张量与更高维张量"><a href="#2-2-4-3D-张量与更高维张量" class="headerlink" title="2.2.4 3D 张量与更高维张量"></a>2.2.4 3D 张量与更高维张量</h3><ul>
<li>将多个矩阵组合成一个新的数组，可以得到一个 3D 张量，你可以将其直观地理解为数字组成的立方体。下面是一个 Numpy 的 3D 张量。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([[[5, 78, 2, 34, 0],</span><br><span class="line"> [6, 79, 3, 35, 1],</span><br><span class="line"> [7, 80, 4, 36, 2]],</span><br><span class="line"> [[5, 78, 2, 34, 0],</span><br><span class="line"> [6, 79, 3, 35, 1],</span><br><span class="line"> [7, 80, 4, 36, 2]],</span><br><span class="line"> [[5, 78, 2, 34, 0],</span><br><span class="line"> [6, 79, 3, 35, 1],</span><br><span class="line"> [7, 80, 4, 36, 2]]])</span><br><span class="line">&gt;&gt;&gt; x.ndim</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
将多个 3D 张量组合成一个数组，可以创建一个 4D 张量，以此类推。深度学习处理的一般是 0D 到 4D 的张量，但处理视频数据时可能会遇到 5D 张量。</li>
</ul>
<h3 id="2-2-5-关键属性"><a href="#2-2-5-关键属性" class="headerlink" title="2.2.5　关键属性"></a>2.2.5　关键属性</h3><ul>
<li>张量是由以下三个关键属性来定义的:</li>
</ul>
<ol>
<li><p><strong>轴的个数（阶）</strong>。例如，3D 张量有 3 个轴，矩阵有 2 个轴。这在 Numpy 等 Python 库中也叫张量的 ndim(轴)。</p>
</li>
<li><p><strong>形状</strong>。这是一个整数元组，表示张量沿每个轴的维度大小（元素个数）。例如，前面矩阵示例的形状为 (3, 5)，3D 张量示例的形状为 (3, 3, 5)。向量的形状只包含一个元素，比如 (5,)，而标量的形状为空，即 ()。</p>
</li>
<li><p><strong>数据类型</strong>（在 Python 库中通常叫作 dtype）。这是张量中所包含数据的类型，例如，张量的类型可以是 float32、uint8、float64 等。在极少数情况下，你可能会遇到字符（char）张量。<strong><em>注意</em></strong>:Numpy（以及大多数其他库）中不存在字符串张量，因为张量存储在预先分配的连续内存段中，而字符串的长度是可变的，无法用这种方式存储。</p>
</li>
</ol>
<h3 id="2-2-7-数据批量的概念"><a href="#2-2-7-数据批量的概念" class="headerlink" title="2.2.7　数据批量的概念"></a>2.2.7　数据批量的概念</h3><ul>
<li><p>通常来说，深度学习中所有数据张量的第一个轴（0 轴，因为索引从 0 开始）都是<strong>样本轴（samples axis，有时也叫样本维度）</strong>。在 MNIST 的例子中，样本就是数字图像。</p>
</li>
<li><p>此外，深度学习模型<strong>不会同时处理整个数据集</strong>，而是<strong>将数据拆分成小批量</strong>。具体来看，下面是 MNIST 数据集的一个批量，批量大小为 128。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">batch = train_images[:128]</span><br><span class="line"><span class="comment">#然后是下一个批量。</span></span><br><span class="line">batch = train_images[128:256]</span><br><span class="line"><span class="comment">#然后是第 n 个批量。</span></span><br><span class="line">batch = train_images[128 * n:128 * (n + 1)]</span><br></pre></td></tr></table></figure>
<p>对于这种批量张量，第一个轴（0 轴）叫作<strong>批量轴（batch axis）</strong>或<strong>批量维度（batch dimension）</strong>。在使用 Keras 和其他深度学习库时会经常遇到这个术语。</p>
</li>
</ul>
<h3 id="2-2-8-现实世界中的数据张量"><a href="#2-2-8-现实世界中的数据张量" class="headerlink" title="2.2.8　现实世界中的数据张量"></a>2.2.8　现实世界中的数据张量</h3><ul>
<li>我们用几个你未来会遇到的示例来具体介绍数据张量。你需要处理的数据几乎总是以下类别之一:</li>
</ul>
<ol>
<li><p><strong>向量数据</strong>：2D 张量，形状为 (samples, features)。</p>
</li>
<li><p><strong>时间序列数据或序列数据</strong>：3D 张量，形状为 (samples, timesteps, features)。</p>
</li>
<li><p><strong>图像</strong>：4D 张量，形状为 (samples, height, width, channels) 或 (samples, channels,height, width)。</p>
</li>
<li><p><strong>视频</strong>：5D 张量，形状为 (samples, frames, height, width, channels) 或 (samples,frames, channels, height, width)。</p>
</li>
</ol>
<h3 id="2-2-9-向量数据"><a href="#2-2-9-向量数据" class="headerlink" title="2.2.9　向量数据"></a>2.2.9　向量数据</h3><ul>
<li>这是最常见的数据。对于这种数据集，每个数据点都被编码为一个向量，因此一个数据批量就被编码为 2D 张量（即向量组成的数组），其中第一个轴是<strong>样本轴</strong>，第二个轴是<strong>特征轴</strong>。以下展示两个例子:</li>
</ul>
<ol>
<li><p><strong>人口统计数据集</strong>:其中包括每个人的年龄、邮编和收入。每个人可以表示为包含 3 个值的向量，而整个数据集包含 100 000 个人，因此可以存储在形状为 (100000, 3) 的 2D张量中。</p>
</li>
<li><p><strong>文本文档数据集</strong>:我们将每个文档表示为每个单词在其中出现的次数（字典中包含20 000 个常见单词）。每个文档可以被编码为包含 20 000 个值的向量（每个值对应于字典中每个单词的出现次数），整个数据集包含 500 个文档，因此可以存储在形状为(500, 20000) 的张量中。</p>
</li>
</ol>
<h3 id="2-2-10-时间序列数据或序列数据"><a href="#2-2-10-时间序列数据或序列数据" class="headerlink" title="2.2.10　时间序列数据或序列数据"></a>2.2.10　时间序列数据或序列数据</h3><ul>
<li>当时间（或序列顺序）对于数据很重要时，应该将数据存储在带有时间轴的 3D 张量中。每个样本可以被编码为一个向量序列（即 2D 张量），因此一个数据批量就被编码为一个 3D 张量。根据惯例，时间轴始终是第 2 个轴（索引为 1 的轴）。以下展示两个例子:</li>
</ul>
<ol>
<li><p><strong>股票价格数据集</strong>。每一分钟，我们将股票的当前价格、前一分钟的最高价格和前一分钟的最低价格保存下来。因此每分钟被编码为一个 3D 向量，整个交易日被编码为一个形状为 (390, 3) 的 2D 张量（一个交易日有 390 分钟），而 250 天的数据则可以保存在一个形状为 (250, 390, 3) 的 3D 张量中。这里每个样本是一天的股票数据。</p>
</li>
<li><p><strong>推文数据集</strong>。我们将每条推文编码为 280 个字符组成的序列，而每个字符又来自于 128个字符组成的字母表。在这种情况下，每个字符可以被编码为大小为 128 的二进制向量（只有在该字符对应的索引位置取值为 1，其他元素都为 0）。那么每条推文可以被编码为一个形状为 (280, 128) 的 2D 张量，而包含 100 万条推文的数据集则可以存储在一个形状为 (1000000, 280, 128) 的张量中。</p>
</li>
</ol>
<h3 id="2-2-11-图像数据"><a href="#2-2-11-图像数据" class="headerlink" title="2.2.11　图像数据"></a>2.2.11　图像数据</h3><ul>
<li><p>图像通常具有三个维度：<strong>高度、宽度和颜色深度</strong>。虽然灰度图像（比如 MNIST 数字图像）只有一个颜色通道，因此可以保存在 2D 张量中，但按照惯例，图像张量始终都是 3D 张量，灰度图像的彩色通道只有一维。因此，如果图像大小为 256×256，那么 128 张灰度图像组成的批量可以保存在一个形状为 (128, 256, 256, 1) 的张量中，而 128 张彩色图像组成的批量则可以保存在一个形状为 (128, 256, 256, 3) 的张量中</p>
</li>
<li><p>图像张量的形状有两种约定：<strong>通道在后（channels-last）</strong>的约定（在 TensorFlow 中使用）和<strong>通道在前（channels-first）</strong>的约定（在 Theano 中使用）。Google 的 TensorFlow 机器学习框架将颜色深度轴放在最后：(samples, height, width, color_depth)。与此相反，Theano将图像深度轴放在批量轴之后：(samples, color_depth, height, width)。如果采用 Theano 约定，前面的两个例子将变成 (128, 1, 256, 256) 和 (128, 3, 256, 256)。Keras 框架同时支持这两种格式。</p>
</li>
</ul>
<h3 id="2-2-12-视频数据"><a href="#2-2-12-视频数据" class="headerlink" title="2.2.12　视频数据"></a>2.2.12　视频数据</h3><ul>
<li>视频数据是现实生活中需要用到 5D 张量的少数数据类型之一。视频可以看作一系列帧，每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_depth) 的 3D 张量中，因此一系列帧可以保存在一个形状为 (frames, height, width,color_depth) 的 4D 张量中，而不同视频组成的批量则可以保存在一个 5D 张量中，其形状为(samples, frames, height, width, color_depth)。举个例子:</li>
</ul>
<ol>
<li>一个以每秒 4 帧采样的 60 秒 YouTube 视频片段，视频尺寸为 144×256，这个视频共有 240 帧。4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3)的张量中。总共有 106 168 320 个值！如果张量的数据类型（dtype）是 float32，每个值都是32 位，那么这个张量共有 405MB。好大！你在现实生活中遇到的视频要小得多，因为它们不以float32 格式存储，而且通常被大大压缩，比如 MPEG 格式。</li>
</ol>
<h2 id="2-3-神经网络的“齿轮”：张量运算"><a href="#2-3-神经网络的“齿轮”：张量运算" class="headerlink" title="2.3　神经网络的“齿轮”：张量运算"></a>2.3　神经网络的“齿轮”：张量运算</h2><blockquote>
<p>所有计算机程序最终都可以简化为二进制输入上的一些二进制运算（AND、OR、NOR 等），与此类似，深度神经网络学到的所有变换也都可以简化为数值数据张量上的一些<strong>张量运算（tensor operation）</strong>。Keras 层的实例如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keras.layers.Dense(512, activation=<span class="string">'relu'</span>)</span><br></pre></td></tr></table></figure>
<p>这个层可以理解为一个函数，输入一个 2D 张量，返回另一个 2D 张量，即输入张量的新表示。具体而言，这个函数如下所示（其中 W 是一个 2D 张量，b 是一个向量，二者都是该层的属性）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output = relu(dot(W, input) + b)</span><br></pre></td></tr></table></figure>
<p>我们将上式拆开来看。这里有三个张量运算：输入张量和张量 W 之间的点积运算（dot）、得到的 2D 张量与向量 b 之间的加法运算（+）、最后的 relu 运算。relu(x) 是 max(x, 0)。</p>
<h3 id="2-3-1-逐元素运算"><a href="#2-3-1-逐元素运算" class="headerlink" title="2.3.1　逐元素运算"></a>2.3.1　逐元素运算</h3><ul>
<li><p>relu 运算和加法都是<strong>逐元素（element-wise）</strong>的运算，即该运算独立地应用于张量中的每个元素，也就是说，这些运算非常适合大规模并行实现（<strong>向量化</strong>实现，这一术语来自于 1970—1990 年间<strong>向量处理器</strong>超级计算机架构）。下列代码是对逐元素 relu 运算的简单实现:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def naive_relu(x):</span><br><span class="line">	assert len(x.shape) == 2 <span class="comment"># x是一个 Numpy 的 2D 张量</span></span><br><span class="line"></span><br><span class="line">	x = x.copy() <span class="comment"># 避免覆盖输入张量</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(x.shape[0]):</span><br><span class="line"> 		<span class="keyword">for</span> j <span class="keyword">in</span> range(x.shape[1]):</span><br><span class="line"> 			x[i,j] = max(x[i, j], 0)</span><br><span class="line">	<span class="built_in">return</span> x</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于加法采用同样的实现方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def naive_add(x, y):</span><br><span class="line">	assert len(x.shape) == 2 <span class="comment"># x 和 y 是 Numpy 的 2D 张量</span></span><br><span class="line">	assert x.shape == y.shape</span><br><span class="line"></span><br><span class="line">	x = x.copy() <span class="comment"># 避免覆盖输入张量</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(x.shape[0]):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(x.shape[1]):</span><br><span class="line">			x[i,j] += y[i, j]</span><br><span class="line">	<span class="built_in">return</span> x</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-2-广播"><a href="#2-3-2-广播" class="headerlink" title="2.3.2　广播"></a>2.3.2　广播</h3><ul>
<li>上一节 naive_add 的简单实现仅支持两个形状相同的 2D 张量相加。但在前面介绍的Dense 层中，我们将一个 2D 张量与一个向量相加。如果将两个形状不同的张量相加——没有歧义的话——较小的张量会被<strong>广播（broadcast）</strong>，以匹配较大张量的形状。广播包含以下两步：</li>
</ul>
<ol>
<li><p>向较小的张量添加轴（叫作<strong>广播轴</strong>），使其 ndim 与较大的张量相同。</p>
</li>
<li><p>将较小的张量沿着新轴重复，使其形状与较大的张量相同。</p>
</li>
</ol>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>《python深度学习》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用tf.concat()与np.concatenate()来拼接向量</title>
    <url>/2020/04/23/%E5%88%A9%E7%94%A8tf.concat()%E4%B8%8Enp.concatenate%E6%9D%A5%E6%8B%BC%E6%8E%A5%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<p>tf.concat()用法展示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf.concat([tensor1, tensor2, tensor3,...], axis)</span><br><span class="line"><span class="comment"># 使用通式，其中tensor1等表示矩阵对象；axis表示拼接的维度，数值越大，纬度越高</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------</span></span><br><span class="line">t1 = [[1, 2, 3], [4, 5, 6]]  t2 = [[7, 8, 9], [10, 11, 12]]  </span><br><span class="line">tf.concat([t1, t2], 0)  </span><br><span class="line"><span class="comment"># [out] : [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]  </span></span><br><span class="line">tf.concat([t1, t2], 1)  </span><br><span class="line"><span class="comment"># [out] : [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]   </span></span><br><span class="line"><span class="comment">#---------------------------------------------------------</span></span><br><span class="line"><span class="comment"># tensor t3 with shape [2, 3]  </span></span><br><span class="line"><span class="comment"># tensor t4 with shape [2, 3]  </span></span><br><span class="line">tf.shape(tf.concat([t3, t4], 0))  <span class="comment"># shape:[4, 3]  </span></span><br><span class="line">tf.shape(tf.concat([t3, t4], 1))  <span class="comment"># shape:[2, 6]</span></span><br></pre></td></tr></table></figure>
<p>简单来讲，对于形状如[[ ], [ ]]和[[ ], [ ]]的矩阵，低维拼接等于拿掉最外面括号，高维拼接是拿掉里面的括号(保证其他维度不变)。如果axis为负数（-num），则表示倒数第num维度。</p>
<hr>
<p>np.concatenate的用法与tf.concat()类似，所以下面只展示示例，不做过多介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">z = np.array([[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],[13, 14, 15, 16]])</span><br><span class="line">a = np.concatenate(z,axis=1)</span><br><span class="line">[out]:</span><br><span class="line">	a = [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 ]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构与算法》笔记(Python语言实现)</title>
    <url>/2020/04/19/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0(Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<h1 id="第一章-Python入门"><a href="#第一章-Python入门" class="headerlink" title="第一章 Python入门"></a>第一章 Python入门</h1><hr>
<h2 id="1-2-Python对象"><a href="#1-2-Python对象" class="headerlink" title="1.2 Python对象"></a>1.2 Python对象</h2><h3 id="1-2-1-标识符、对象和赋值语句"><a href="#1-2-1-标识符、对象和赋值语句" class="headerlink" title="1.2.1 标识符、对象和赋值语句"></a>1.2.1 标识符、对象和赋值语句</h3><blockquote>
<p>概念理解</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">temperature = 98.6</span><br><span class="line"><span class="comment"># [temperature = 98.6] - 赋值语句</span></span><br><span class="line"><span class="comment"># temperature - 标识符</span></span><br><span class="line"><span class="comment"># 98.6 - 对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>标识符的引用原理</p>
</blockquote>
<ul>
<li>程序员可以向现有对象指定第二个标识符建立一个别名<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">temperature = 98.6</span><br><span class="line">original = temperature</span><br><span class="line"><span class="comment"># 这里标识符[original]和标识符[temperature]都是对象[98.6]的别名</span></span><br></pre></td></tr></table></figure></li>
<li>一旦建立了别名，两个名称都可以用来访问底层对象。如果对象的一个别名被赋值语句重新赋予了新的值，那么这并不影响已存在的对象，而是给别名重新分配了存储对象<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">temperature = temperature +5.0</span><br><span class="line">original</span><br><span class="line"></span><br><span class="line">[out]:</span><br><span class="line">	temperature = 103.6</span><br><span class="line">	original = 98.6</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<h3 id="1-2-3-Python的内置类"><a href="#1-2-3-Python的内置类" class="headerlink" title="1.2.3 Python的内置类"></a>1.2.3 Python的内置类</h3><blockquote>
<p>浮点类</p>
</blockquote>
<ul>
<li>在转化字符型的数字时，建议使用<strong>float（而不是int）</strong>进行转换<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span>(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">[out]:</span><br><span class="line">	3.0</span><br><span class="line"><span class="comment">#------------------------</span></span><br><span class="line"><span class="built_in">float</span>(<span class="string">'3.14'</span>)</span><br><span class="line"></span><br><span class="line">[out]:</span><br><span class="line">	3.14</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set类和frozenset类</p>
</blockquote>
</li>
<li>set类和frozenset类都属于<strong>集合类型</strong>（frozenset类是集合类型的一种不可变的形式）</li>
<li>集合内的元素是<strong>无序</strong>的且只有<strong>不可变类型</strong>的实例才可以被添加到集合中（所以frozenset类是可以添加进集合的）</li>
</ul>
<h2 id="1-3-表达式、运算符和优先级"><a href="#1-3-表达式、运算符和优先级" class="headerlink" title="1.3 表达式、运算符和优先级"></a>1.3 表达式、运算符和优先级</h2><blockquote>
<p>算术运算符</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ 加</span><br><span class="line">- 减</span><br><span class="line">* 乘</span><br><span class="line">/ 真正的除</span><br><span class="line">// 整数除法</span><br><span class="line">% 模运算符</span><br></pre></td></tr></table></figure>
<ul>
<li>Python严谨地扩展了//和%的语义。q=n//m和r=n%m，Python保证q*m+r=n<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = 27</span><br><span class="line">b = -4</span><br><span class="line">a % b <span class="comment"># a % b == -1 </span></span><br><span class="line">a//b <span class="comment"># a//b == -7</span></span><br><span class="line">(a//b)*(b)+(a % b)==a <span class="comment"># (-7)*(-4)+(-1)==27</span></span><br><span class="line"><span class="comment">#--------------------------</span></span><br><span class="line"><span class="comment">#  在浮点数运算也是这样，但又有点不一样</span></span><br><span class="line">a=8.2</span><br><span class="line">b=3.14</span><br><span class="line">a//b <span class="comment"># a//b == 2.0</span></span><br><span class="line">a%b <span class="comment"># a%b == 1.919999999999999</span></span><br><span class="line"><span class="comment"># 1.919999999999999==1.92 &gt;&gt; False</span></span><br><span class="line">(a//b)*b+(a%b)==a <span class="comment"># (a//b)*b+(a%b)==a &gt;&gt; True</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>《数据结构与算法》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas在Python语言下的基础使用</title>
    <url>/2020/04/14/Pandas%E5%9C%A8Python%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>Pandas是个强大的结构数据处理包，但依本人经验来看：<strong>强烈建议在保存Pandas的DataFrame数据时，最好转化为numpy数组文件（.npy）进行保存</strong></li>
</ul>
<p><em>从实际使用来看，如果将DataFrame数据保存为csv或txt文件，在重新加载数据文件时，数据类型会自动转换成str类型，带来不必要的麻烦</em></p>
<blockquote>
<p>以下是我在实际应用&lt;预测关键蛋白&gt;中的实例</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proteins_interaction_name=list(proteins_interaction_relationship.keys()) </span><br><span class="line"><span class="comment"># 将蛋白质名称列表赋值给对象proteins_interaction_name</span></span><br><span class="line">a = [proteins_interaction_relationship,proteins_labels] </span><br><span class="line"><span class="comment"># proteins_interaction_relationship以及proteins_labelsd都是字典对象</span></span><br><span class="line">data_preprocessing = pd.DataFrame(a,index=[<span class="string">'Proteins_interaction_relationship'</span>,<span class="string">'proteins_labels'</span>]) </span><br><span class="line"><span class="comment"># 通过pd.DataFrame内置函数依照proteins_interaction_relationship以及proteins_labelsd字典对象构建Pandas的DataFrame</span></span><br><span class="line"><span class="comment"># index为pd.DataFrame的内置属性，用于给每行添加索引</span></span><br><span class="line">data_preprocessing = data_preprocessing.dropna(axis=1)  </span><br><span class="line"><span class="comment"># 通过[DataFrame](代指DataFrame类型对象).dropna内置函数删除含有空值的列（axis=0为行） </span></span><br><span class="line">data_preprocessing.loc[2]=proteins_interaction_name</span><br><span class="line"><span class="comment"># 通过[DataFrame].loc[num]将proteins_interaction_name列表插入到第（num+1）行</span></span><br><span class="line">data_preprocessing.to_numpy</span><br><span class="line"><span class="comment"># 将数据转化成numpy数组类型，这样在保存数据时可以避免很多麻烦</span></span><br><span class="line">np.save(<span class="string">'data_preprocessing_DataFrame.npy'</span>,data_preprocessing) <span class="comment"># 保存Pandas结构数据</span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>以下是读取csv时的一些值得注意的操作（不推荐保存为csv，但建议掌握以备不时之需）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=pd.read_csv(<span class="string">'data_preprocessing_DataFrame(无索引).csv'</span>,header=None)</span><br><span class="line"><span class="comment"># 注意：如果无列索引，必须添加header=None，否则默认把第一行数据处理成列名导致缺失</span></span><br><span class="line">a.values</span><br><span class="line"><span class="comment"># 通过这个操作，可以将对象a重新转化为DataFrame数据结构&lt;注意：此时数据的类型已经全部转化为str类型&gt;</span></span><br><span class="line">data_preprocessing.to_csv(<span class="string">'data_preprocessing_DataFrame(无索引).csv'</span>,index=False,header=False) </span><br><span class="line"><span class="comment"># 只保存DataFrame的数据，index=False表示无行索引，header=False表示无列索引</span></span><br><span class="line">data_preprocessing.to_csv(<span class="string">'data_preprocessing_DataFrame.csv'</span>) </span><br><span class="line"><span class="comment"># 保存DataFrame的数据及索引</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Python机器学习基础教程》笔记(scikit-learn框架)</title>
    <url>/2020/04/13/%E3%80%8APython%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0(scikit-learn%E6%A1%86%E6%9E%B6)/</url>
    <content><![CDATA[<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><hr>
<h2 id="1-7-第一个应用：鸢（yuan）尾花分类"><a href="#1-7-第一个应用：鸢（yuan）尾花分类" class="headerlink" title="1.7 第一个应用：鸢（yuan）尾花分类"></a>1.7 第一个应用：鸢（yuan）尾花分类</h2><h3 id="1-7-3-要事第一：观察数据"><a href="#1-7-3-要事第一：观察数据" class="headerlink" title="1.7.3 要事第一：观察数据"></a>1.7.3 要事第一：观察数据</h3><blockquote>
<p>在构建模型时，最重要的是要首先<strong>观察数据</strong>。<br>检查数据的最佳方法就是将其<strong>可视化</strong>。<br>当数据<strong>只有两个特征</strong>时，可以使用<strong>散点图</strong>。<br>当数据<strong>有多个特征</strong>时，解决这个问题的一种方法就是绘制<strong>散点图矩阵</strong>(pair plot)。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下为绘制散点图矩阵的示例程序</span></span><br><span class="line"><span class="comment"># scatter_matrix为pandas绘制散点图矩阵的函数,矩阵的对角线是每个特征的直方图</span></span><br><span class="line"><span class="comment"># 利用X_train中的数据创建DataFrame</span></span><br><span class="line"><span class="comment"># 利用iris_dataset.feature_names中的字符串对数据列进行标记</span></span><br><span class="line">iris_dataframe = pd.DataFrame(X_train, columns = iris_dataset.feature_names)</span><br><span class="line"><span class="comment"># 利用DataFrame创建散点图矩阵，按y_train着色</span></span><br><span class="line">grr = pd.scatter_matrix(iris_dataframe, c = y_train, figsize = (15,15), marker = <span class="string">'o'</span> ...)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-7-4-构建第一个模型：k近邻算法"><a href="#1-7-4-构建第一个模型：k近邻算法" class="headerlink" title="1.7.4 构建第一个模型：k近邻算法"></a>1.7.4 构建第一个模型：k近邻算法</h3><blockquote>
<p>k近邻算法：算法会在训练集中寻找与这个新数据点A最近的任意k个邻居（这也是&lt;k近邻算法&gt;中’k’的含义），然后将找到的数据点的标签赋值给这个新数据点A。<br>scikit-learn中所有的机器学习模型都是在各自的被作为[Estimator]的类中完成的。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k近邻算法是在neighbors模块的KNeighborsClassifier类中实现的</span></span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = 1)</span><br><span class="line"><span class="comment"># n_neighbors是KNeighborsClassifier最重要的参数，表示邻居的数目</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-5-做出预测"><a href="#1-7-5-做出预测" class="headerlink" title="1.7.5 做出预测"></a>1.7.5 做出预测</h3><blockquote>
<p>scikit-learn的输入数据必须是二维数组。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用knn对象的predict方法来进行预测：</span></span><br><span class="line">prediction = knn.predict(X_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Prediction :"</span>.format(prediction))</span><br><span class="line"><span class="comment"># [out]:Prediction :[0](标签数据)</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="第二章-监督学习"><a href="#第二章-监督学习" class="headerlink" title="第二章 监督学习"></a>第二章 监督学习</h1><hr>
<h2 id="2-1-分类与回归"><a href="#2-1-分类与回归" class="headerlink" title="2.1 分类与回归"></a>2.1 分类与回归</h2>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>《Python机器学习基础教程》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scikit-learn</tag>
      </tags>
  </entry>
  <entry>
    <title>python画散点图[plt.scatter()]以及矩阵散点图[pd.scatter_matrix()]详解（待优化）</title>
    <url>/2020/04/13/python%E7%94%BB%E6%95%A3%E7%82%B9%E5%9B%BE%5Bplt.scatter()%5D%E4%BB%A5%E5%8F%8A%E7%9F%A9%E9%98%B5%E6%95%A3%E7%82%B9%E5%9B%BE%5Bpd.scatter_matrix()%5D%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="plt-scatter-散点图"><a href="#plt-scatter-散点图" class="headerlink" title="plt.scatter() 散点图"></a>plt.scatter() 散点图</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plt.scatter( x, y, s=20, c = None, marker = <span class="string">'o'</span>, cmap = none, norm = none, vmin = none, vmax = none, alpha = none, linewidths = none,</span><br><span class="line">	verts = none, edgecolors = none, hold = none,**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li>s:散点的大小</li>
<li>c:散点的颜色，’r ‘/‘g’/‘y’/‘w’/‘k’…….</li>
<li>marker:散点形状,  ‘.’(点)/‘o’(圆)/‘v’(倒三角形)/‘ * ‘(星星)/‘s’(正方形)………</li>
<li>cmap：colormap，颜色版：’accent’,’blues’,’bugn’,’oranges’….</li>
<li>vmin，vmax:亮度设置，标亮</li>
<li>alpha ：颜色透明程度， 实数，0-1之间</li>
<li>linewidths:线的宽度</li>
<li>linestyle: 线的风格，’–’（虚线）/ ‘-‘ (直线) / ‘-.’(间隔虚线)/ ‘: ‘(全为点)</li>
</ul>
<hr>
<h1 id="pd-scatter-matrix-散点图"><a href="#pd-scatter-matrix-散点图" class="headerlink" title="pd.scatter_matrix()散点图"></a>pd.scatter_matrix()散点图</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scatter_matrix([frame], alpha=0.5, c, figsize=None, ax=None, diagonal=<span class="string">'hist'</span>, marker=<span class="string">'.'</span>, density_kwds=None, hist_kwds=None, </span><br><span class="line">	y range_padding=0.05, **kwds)</span><br></pre></td></tr></table></figure>
<ol>
<li>frame - pandas dataframe变量对象 </li>
<li>alpha -  图像透明度，一般取(0,1] </li>
<li>figsize - 以英寸为单位的图像大小，一般以元组 (width, height) 形式设置 </li>
<li>ax - 可选一般为none </li>
<li>diagonal - 必须且只能在{‘hist’, ‘kde’}中选择1个，’hist’表示直方图(Histogram plot),’kde’表示核密度估计(Kernel Density Estimation)；该参数是scatter_matrix函数的关键参数 </li>
<li>marker - Matplotlib可用的标记类型，如’.’，’,’，’o’等 </li>
<li>density_kwds - (other plotting keyword arguments，可选)，与kde相关的字典参数 </li>
<li>hist_kwds - 与hist相关的字典参数 </li>
<li>range_padding - (float, 可选)，图像在x轴、y轴原点附近的留白(padding)，该值越大，留白距离越大，图像远离坐标原点 </li>
<li>kwds - 与scatter_matrix函数本身相关的字典参数 </li>
<li>c - 颜色（可以用数字标签决定颜色）</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 数据可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用TensorFlow实现简单的机器学习</title>
    <url>/2020/04/10/%E5%88%A9%E7%94%A8TensorFlow%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>该框架原型请参见TensorFlow官方教程《<a href="https://tensorflow.google.cn/tutorials/keras/text_classification" target="_blank" rel="noopener">对预文本进行文本分类处理</a>》</p>
</blockquote>
<p><em>以下是我利用(访问官网请点击)<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">TensorFlow</a>构建&lt;预测关键蛋白&gt;算法框架时实际使用的源码</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow import keras</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------- 加载蛋白质字典</span></span><br><span class="line">protein_dictionary_matrix = np.load(<span class="string">'&lt;文件路径&gt;'</span>) <span class="comment"># 字典数据示例:&#123;('A':1,2,3),('B':2,5)&#125;</span></span><br><span class="line"><span class="comment">#------------------------- 将蛋白质语句长度标准化</span></span><br><span class="line">protein_dictionary_matrix = tf.contrib.keras.preprocessing.sequence.pad_sequences</span><br><span class="line">(protein_dictionary_matrix,maxlen=None,padding=<span class="string">'post'</span>,truncating=<span class="string">'post'</span>,value = 0)</span><br><span class="line"><span class="comment"># 具体用法可参见文章《如何利用Python将数组长度标准化》</span></span><br><span class="line"><span class="comment">#-------------------------------加载蛋白质标签矩阵</span></span><br><span class="line">proteins_labels_num = np.load(<span class="string">'&lt;文件路径&gt;'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------构建模型</span></span><br><span class="line">proteins_size = len(proteins_labels_num)*len(protein_dictionary_matrix[1]) <span class="comment"># 蛋白质数量*标准矩阵长度</span></span><br><span class="line"></span><br><span class="line">model = keras.Sequential()</span><br><span class="line">model.add(keras.layers.Embedding(proteins_size, 16))</span><br><span class="line"><span class="comment"># 第一层是嵌入Embedding层。该层采用整数编码的词汇表，并查找每个词索引的嵌入向量(embedding vector)</span></span><br><span class="line"><span class="comment"># 这些向量是通过模型训练学习到的。向量向输出数组增加了一个维度。得到的维度为：(batch, sequence, embedding)。</span></span><br><span class="line">model.add(keras.layers.GlobalAveragePooling1D())</span><br><span class="line"><span class="comment"># GlobalAveragePooling1D 将通过对序列维度求平均值来为每个样本返回一个定长输出向量。这允许模型以尽可能最简单的方式处理变长输入。</span></span><br><span class="line">model.add(keras.layers.Dense(16, activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="comment"># 该定长输出向量通过一个有 16 个隐层单元的全连接（Dense）层传输。</span></span><br><span class="line">model.add(keras.layers.Dense(1, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"><span class="comment"># 最后一层与单个输出结点密集连接。使用 Sigmoid 激活函数，其函数值为介于0与1之间的浮点数，表示概率或置信度。</span></span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment">#------------------------------损失函数与优化器</span></span><br><span class="line"><span class="comment"># 一个模型需要损失函数和优化器来进行训练。由于这是一个二分类问题且模型输出概率值（一个使用 sigmoid 激活函数的单一单元层），</span></span><br><span class="line"><span class="comment"># 我们将使用 binary_crossentropy 损失函数。</span></span><br><span class="line"><span class="comment"># 这不是损失函数的唯一选择，例如，你还可以选择 mean_squared_error。</span></span><br><span class="line"><span class="comment"># 但是，一般来说binary_crossentropy更适合处理概率——它能够度量概率分布之间的“距离”，或者在我们的示例中，指的是度量 ground-truth 分布与预测值之间的“距离”。</span></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------对数据进行切割处理</span></span><br><span class="line">x_val = protein_dictionary_matrix[:1000] <span class="comment"># 实验集</span></span><br><span class="line">partial_x_train = protein_dictionary_matrix[1000:] <span class="comment"># 验证集</span></span><br><span class="line"></span><br><span class="line">y_val = proteins_labels_num[:1000] <span class="comment"># 实验集</span></span><br><span class="line">partial_y_train = proteins_labels_num[1000:] <span class="comment"># 验证集</span></span><br><span class="line"><span class="comment">#---------------------------------训练模型</span></span><br><span class="line"><span class="built_in">history</span> = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=10,			<span class="comment"># 迭代次数</span></span><br><span class="line">                    batch_size=300,		<span class="comment"># 每次迭代的批量大小</span></span><br><span class="line">                    validation_data=(x_val, y_val),</span><br><span class="line">                    verbose=1)</span><br><span class="line"><span class="comment">#---------------------------------------------------------------评估模型</span></span><br><span class="line"><span class="comment"># 将返回两个值。损失值&lt;loss&gt;（一个表示误差的数字，值越低越好）与准确率&lt;accuracy&gt;（值越高越好）</span></span><br><span class="line">results = model.evaluate(protein_dictionary_matrix,  proteins_labels_num, verbose=2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 框架用法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>关键蛋白预测</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字典中利用setdefault()函数创建字典</title>
    <url>/2020/04/09/Python%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8setdefault()%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<blockquote>
<p>关于该函数实际用法，可以参考文章《利用zip解决Python中字典自动正序带来的关系数据错位问题》(可通过博客搜索功能快速查找)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python字典中的setdefault()函数：如果键不存在于字典中，将会添加键并将值设为默认值。</span></span><br><span class="line">dict.setdefault(key, default=None)</span><br><span class="line"><span class="comment"># dict -- 代指字典变量</span></span><br><span class="line"><span class="comment"># key -- 查找的键值。</span></span><br><span class="line"><span class="comment"># default -- 键不存在时，设置的默认键值。None为空值</span></span><br><span class="line"><span class="comment"># 对于default，可以设置set()等空列表或集合用以规定值的存储方式</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用zip解决Python中字典自动正序带来的关系数据错位问题</title>
    <url>/2020/04/09/%E5%88%A9%E7%94%A8zip%E8%A7%A3%E5%86%B3Python%E4%B8%AD%E5%AD%97%E5%85%B8%E8%87%AA%E5%8A%A8%E6%AD%A3%E5%BA%8F%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>本问题最初出现在构建蛋白质的关系字典中</p>
</blockquote>
<ul>
<li>由于在字典中，数据的排序是自动正序的（也可以理解为乱序），在一组关系数据列表中，<br>我们构建字典的方式往往是先提取一组数据构建字典的键，再提取另一组数据一一对应为键的值 。但是由于字典的键是乱序的，那么对应的值也必然是错误的。本方法就是为了解决这个问题。</li>
</ul>
<p><em>如果你对问题的描述仍有疑惑，下面的示例代码将有助于你的理解以及对你遇到的问题的解决</em><br><em>关于setdefault()函数的使用，可以参考文章《Python字典中setdefault()函数的用法》</em>(可通过博客搜索功能快速查找)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为帮助你理解程序，我们假设一组关系数据[A-a，B-b，C-c，D-d]</span></span><br><span class="line"><span class="comment"># 以上数据表明A与a之间存在关系，可以理解为A与a互为标签（事实上在本实例中也确实是这样处理的）</span></span><br><span class="line"></span><br><span class="line">proteins_interaction_relationship = &#123;&#125; </span><br><span class="line"><span class="comment"># 首先，我们创建一个空的字典proteins_interaction_relationship </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------- 创建相互作用关系语句</span></span><br><span class="line"><span class="comment"># protein_name1表示列表[A B C D]</span></span><br><span class="line"><span class="comment"># protein_name11表示列表[a b c d]</span></span><br><span class="line"><span class="comment"># dictionaries是一个字典&#123;A:1,B:2,C:3,D:4,a:5,b:6,c:7,d:8&#125;,该变量对代码理解影响不大。</span></span><br><span class="line"><span class="comment"># 使用setdefault()，它可以使我们不用提前给字典输入键，即精简了代码，又减小了BUG发生的概率。</span></span><br><span class="line"><span class="comment"># setdefault().add中add表示向set()空集中添加元素</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(protein_name1,protein_name11):</span><br><span class="line">    proteins_interaction_relationship.setdefault(i,<span class="built_in">set</span>()).add(dictionaries[j])</span><br><span class="line"><span class="comment"># 在for循环中使用zip可以同时提取同一行相互存在关系的两个元素，键的创建和键的赋值是同时进行的，避免了关系数据错位。</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(protein_name11,protein_name1):</span><br><span class="line">    proteins_interaction_relationship.setdefault(i, <span class="built_in">set</span>()).add(dictionaries[j])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>关键蛋白预测</tag>
      </tags>
  </entry>
  <entry>
    <title>非负矩阵分解（NMF）的Matlab实现</title>
    <url>/2020/04/08/%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%EF%BC%88NMF%EF%BC%89%E7%9A%84Matlab%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>非负矩阵分解(Nonnegative Matrix Factorization),简称NMF,是由Lee和Seung于1999年在自然杂志上提出的一种矩阵分解</p>
</blockquote>
<ul>
<li>它使分解后的所有分量均为非负值(要求纯加性的描述)并且同时实现非线性的维数约减.</li>
<li>NMF已逐渐成为信号处理、生物医学工程、模式识别、计算机视觉和图像工程等研究领域中最受欢迎的多维数据处理工具之一.<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">V=double(imread(<span class="string">'图片名或路径'</span>));      <span class="comment">#	这里的图片默认为RGB格式（即三通道图片）</span></span><br><span class="line">imshow(mat2gray(V));</span><br><span class="line">V1=V(:,:,1);		<span class="comment"># 将图片的第一通道数值赋值给V1</span></span><br><span class="line">V2=V(:,:,2);		<span class="comment"># 将图片的第二通道数值赋值给V2</span></span><br><span class="line">V3=V(:,:,3);		<span class="comment"># 将图片的第三通道数值赋值给V3</span></span><br><span class="line"></span><br><span class="line">[i,u]=size(V1);		<span class="comment"># 将V1的行数赋值给i，列数赋值给u</span></span><br><span class="line">r=100;				<span class="comment"># 设置分解矩阵的秩</span></span><br><span class="line">W=rand(i,r);		<span class="comment"># 初始化WH，为非负数</span></span><br><span class="line">H=rand(r,u);		<span class="comment"># 初始化WH，为非负数</span></span><br><span class="line">maviter=600;		<span class="comment"># 最大迭代次数</span></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 以下为非负矩阵算法公式，V2，V3同上处理，就不重复展示,以'...'代替</span></span><br><span class="line"><span class="keyword">for</span> iter=1:maviter</span><br><span class="line">    W=W.*((V1./(W*H))*H<span class="string">');           	</span></span><br><span class="line"><span class="string">    W=W./(ones(i,1)*sum(W));    </span></span><br><span class="line"><span class="string">    H=H.*(W'</span>*(V1./(W*H)));</span><br><span class="line">end</span><br><span class="line">V1=W*H;</span><br><span class="line">...</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 以下程序用于重新拼接图形</span></span><br><span class="line">img_V(:,:,1)=V1(:,:);</span><br><span class="line">img_V(:,:,2)=V2(:,:);</span><br><span class="line">img_V(:,:,3)=V3(:,:);</span><br><span class="line">figure;</span><br><span class="line">imshow(mat2gray(img_V));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Matlab 算法实现</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python将数组长度标准化</title>
    <url>/2020/04/08/%E5%88%A9%E7%94%A8Python%E5%B0%86%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>本方法需要使用tensorflow包，请确认你已安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf  </span><br><span class="line">from tensorflow import keras</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------- 将蛋白质语句长度标准化</span></span><br><span class="line">protein_dictionary_matrix = np.load(<span class="string">'文件路径'</span>) <span class="comment"># 载入数组</span></span><br><span class="line"></span><br><span class="line">protein_dictionary_matrix = keras.preprocessing.sequence.pad_sequences[适用于tensorflow2.0]</span><br><span class="line">(protein_dictionary_matrix,maxlen=None,padding=<span class="string">'post'</span>,truncating=<span class="string">'post'</span>,value = 0)</span><br><span class="line"><span class="comment"># protein_dictionary_matrix:	所要标准化的变量</span></span><br><span class="line"><span class="comment"># maxlen=None:	标准化长度:，None表示以数组最大长度为准</span></span><br><span class="line"><span class="comment"># padding='post':	'pre'或'post'，确定当需要补0时，从起始还是结尾补</span></span><br><span class="line"><span class="comment"># truncating:	'pre'或'post'，确定当需要截断序列时，从起始还是结尾截断</span></span><br><span class="line"><span class="comment"># value:	浮点数，将在填充时嵌入此值,默认的填充值0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 问题解决</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python如何读取Excel文件</title>
    <url>/2020/04/08/Python%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96Excel%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>首先需在Python下安装xlrd包</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install  xlrd <span class="comment"># cmd窗口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。<br>由于xlrd使用更为频繁，这里只简单介绍xlrd读取Excel文件的用法</li>
</ul>
<hr>
<blockquote>
<p>以下为语法介绍</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import xlrd <span class="comment"># 首先在Python程序中加载xlrd包</span></span><br><span class="line"></span><br><span class="line">data1 = xlrd.open_workbook(<span class="string">'数据文件路径'</span>) <span class="comment"># 首先加载文件，并赋值给一个变量</span></span><br><span class="line">*</span><br><span class="line">table1 = data1.sheets()[0] <span class="comment"># 通过索引顺序获取。从data1变量中提取数据，并保存在变量table1中。</span></span><br><span class="line">table1 = data.sheet_by_name(sheet_name) <span class="comment"># 通过名称获取</span></span><br><span class="line"><span class="comment">#以上两个函数都会返回一个xlrd.sheet.Sheet()对象</span></span><br><span class="line">*</span><br><span class="line">protein_name1 = table1.col_values(num) <span class="comment"># table1.col_values提取*列方向的数据为列表，num=第几列（0为第一列）</span></span><br><span class="line">protein_name1 = table1.row_values(num) <span class="comment"># table1.row_values提取*行方向的数据为列表，num=第几行（0为第一行）</span></span><br><span class="line">*</span><br><span class="line">nrows = table.nrows  <span class="comment"># 获取该sheet中的有效*行数</span></span><br><span class="line">ncols = table.ncols  <span class="comment"># 获取该sheet中的有效*列数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 基础语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python将数据可视化为无向图（图论）</title>
    <url>/2020/04/08/%E5%88%A9%E7%94%A8Python%E5%B0%86%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%BA%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>以下以绘制蛋白质相互作用矩阵为例</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import xlrd </span><br><span class="line"><span class="comment"># 原文件为Excel文件，故需调用xlrd包</span></span><br><span class="line"><span class="comment"># 相关使用可查阅另一篇文章《Python如何读取Excel文件》</span></span><br><span class="line">import numpy as np</span><br><span class="line">import networkx as nx</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------- 加载数据</span></span><br><span class="line">data1 = xlrd.open_workbook(<span class="string">'（数据文件路径）'</span>)</span><br><span class="line">data2 = xlrd.open_workbook(<span class="string">'（数据文件路径）'</span>)</span><br><span class="line">table1 = data1.sheets()[0]</span><br><span class="line">table2 = data2.sheets()[0]</span><br><span class="line"></span><br><span class="line">protein_name1 = table1.col_values(0)</span><br><span class="line">protein_name2 = table2.col_values(0)</span><br><span class="line">protein_name11 = table1.col_values(1)</span><br><span class="line">protein_name22 = table2.col_values(1)</span><br><span class="line"><span class="comment">#--------------------------- 数据可视化 </span></span><br><span class="line">G = nx.Graph() <span class="comment"># 首先创建一个空的无向图</span></span><br><span class="line">G.add_edges_from(zip(protein_name1,protein_name11)) <span class="comment"># zip将两个数组合并打包为一个（个人理解）</span></span><br><span class="line">nx.draw(G, with_labels=True) <span class="comment"># with_labels，节点是否带有标签，默认为true</span></span><br><span class="line">plt.show() <span class="comment"># 绘制图形</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Python 数据可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>关键蛋白预测</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo如何插入本地图片</title>
    <url>/2020/04/07/Hexo%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<ul>
<li>由于某种原因安装图片插件安装不上，故使用此方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo写作语法</title>
    <url>/2020/04/07/Hexo%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>以下是效果展示:</p>
</blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p><del>这是横线</del><br><strong>这是加粗</strong><br><em>这是斜体</em></p>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<ol>
<li>有序排列1</li>
<li>有序排列2<br><code>内嵌代码</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码块</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用</p>
</blockquote>
<a id="more"></a>
</li>
</ol>
<hr>
<blockquote>
<p>以下为源代码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题	</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line">~~这是横线~~	</span><br><span class="line">**这是加粗**	</span><br><span class="line">*这是斜体*</span><br><span class="line">* 无序列表1</span><br><span class="line">* 无序列表2</span><br><span class="line">1. 有序排列1</span><br><span class="line">2. 有序排列2</span><br><span class="line">`内嵌代码`</span><br><span class="line">` ` `  <span class="comment">#无间隔</span></span><br><span class="line">代码块</span><br><span class="line">` ` `  <span class="comment">#无间隔</span></span><br><span class="line">&gt;引用</span><br><span class="line">文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
